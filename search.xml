<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS常见的‘坑’]]></title>
    <url>%2F2018%2F05%2F17%2Fjs_keng%2F</url>
    <content type="text"><![CDATA[ES6小坑1.ES6为参数提供了默认值，在定义函数的同时初始化了这个参数，以便在参数没有被传递进去使用123function test (arg = 100) &#123; console.log(num)&#125; test(0) =&gt; 0test() =&gt; 100test(200) =&gt; 200 相对于ES5，arg = arg || 100这样设置参数默认值的时候，传入0时，就会输出false 2.ES6重构代码第一题： var jsonParse = require(&apos;body-parser&apos;).jsonParse import { jsonParse } from ‘body-parser’ 第二题： var body = request.body var username = body.username var password = body.password const {body, body: { username , password} } = request 3.‘…’ 组装对象或者数组 12const color = [&apos;red&apos;, &apos;yellow&apos;, &apos;blue&apos;]const colorful = [...color, &apos;green&apos;, &apos;pink&apos;] colorful =&gt; [‘red’, ‘yellow’, ‘blue’, ‘green’, ‘pink’] 12const people = &#123; name: &apos;pig&apos;, sex: &apos;female&apos;&#125;const newpeople = &#123; ...people, age: &apos;18&apos;&#125; newpeople =&gt; { name: ‘pig’, sex: ‘female’, age: ‘18’} 获取数组或者对象中除了前几项的其他项或者除了某项中的其他项 12const number = [1, 2, 3, 4, 5]const [first, ...rest] = number rest =&gt; 2, 3, 4, 5 12const user = &#123; name: &apos;pig&apos;, age: &apos;18&apos;, sex: &apos;female&apos;&#125;const &#123; name, ...rest &#125; = user rest =&gt; { age: ‘18’, sex: ‘female’ } 组合新对象，当两个对象合并有重复的时候，右面的属性名覆盖左面属性名 123const first = &#123; a: 1, b: 2, c: 3&#125;const second = &#123; c: 6, d: 4, e: 5&#125;const tatol = &#123; ...fisrt, ...second &#125; total =&gt; { a: 1, b: 2, c: 6, d: 4, e: 5} 4.promise12345678910111213setTimeout ( () =&gt; &#123; console.log(1) &#125;,0) new Promise ( (resolve) =&gt; &#123; console.log(2) for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve() &#125; console.log(3) &#125;).then(() =&gt; &#123; console.log(4) &#125;) console.log(5) 控制台输出：2，3，5，4，1 这道题主要为js的运行机制，首先setTimeout，设置了一个定时，定时结束后才会将这个函数放到任务队列里面，所以最后输出 promise的函数均是立即执行，所以直接输出2，3 then放到当前的tick最后，所以先输出5后在输出4，最后的定时的1 1234567891011const promise = new Promise((resolve, reject) =&gt; &#123; resolve(&apos;success1&apos;) reject(&apos;error&apos;) resolve(&apos;success2&apos;) &#125;) promise.then((res) =&gt; &#123; console.log(&apos;then: &apos;, res) &#125;) .catch((err) =&gt; &#123; console.log(&apos;catch: &apos;, err) &#125;) 控制台输出：then：success1 promise只会识别一种状态，当识别到了resolve状态时，后面的状态就忽略了，resolve代表成功，所以走的是then，输出success1 JS小坑1.循环，闭包，加延时123for (var i = 0; i &lt; 5; i ++) &#123; console.log(i)&#125; 输出：0，1，2，3，4 正常输出值 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout( () =&gt; &#123; console.log(i) &#125;, 1000 * i)&#125; 输出：5，5，5，5，5 因为for循环是一次性走完的，但是添加了异步的操作，当for循环结束后，i的作用域还存在，而且在他的内部还可以访问，所以就等于5了 1234567for (var i = 0; i &lt; 5; i++) &#123; ((i) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, i * 1000) &#125;)(i)&#125; 输出：0，1，2，3，4 添加了闭包操作，没执行一次i循环，就会一秒后输出i值 1234567for (var i = 0; i &lt; 5; i++) &#123; (() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, i * 1000) &#125;)(i)&#125; 输出：5，5，5，5，5 添加了闭包操作，但是（）内没有添加闭包值，没有对i保持引用，所以还是输出5 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(((i) =&gt; &#123; console.log(i) &#125;)(i), i * 1000)&#125; 立即输出，没有延时：0，1，2，3，4 setTimeout这里传递了一个立即执行函数，所以后面的延时时间不进行考虑，所以立即输出0，1，2，3，4 2.循环，闭包（1）循环 123456789101112131415test6 () &#123; var results = this.count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2];&#125;,count() &#123; var arr = []; for (var i = 1; i &lt;= 3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125; f1 =&gt; function () { return i * i } f2 =&gt; function () { return i * i } f3 =&gt; function () { return i * i } f1() =&gt; 16 push的时候只是定义了函数，在执行时，i已经变成了4 f2() =&gt; 16 f3() =&gt; 16 （2）将（1）中的循环改成闭包 123456789101112131415161718test6 () &#123; var results = this.count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2];&#125;,count() &#123; var arr = []; for (var i = 1; i &lt;= 3; i++) &#123; arr.push((function(n)&#123; return function () &#123; return n * n; &#125; &#125;)(i)); // console.log(i) &#125; return arr;&#125; f1 =&gt; function () { return n * n } f2 =&gt; function () { return n * n } f3 =&gt; function () { return n * n } f1() =&gt; 1 f2() =&gt; 4 f3() =&gt; 9 (3) 将（1）中的var改成let时，就会生成和闭包一样的效果，因为es6的let能让变量长期存在于内存，而且又不是全局的 123456789101112131415161718test6 () &#123; var results = this.count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2]; console.log(f1()) console.log(f2()) console.log(f3())&#125;,count() &#123; var arr = []; for (let i = 1; i &lt;= 3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建属于你的专属博客]]></title>
    <url>%2F2018%2F05%2F15%2Ftest%2F</url>
    <content type="text"><![CDATA[第一步：安装以及运行1.安装git以及node环境（官网下载即可）2.在node的环境下安装hexo cnpm install -g hexo-cli cnpm install -g hexo hexo -v 检验是否安装成功 3.本地创建放置博客文章文件并与github相连接 mkdir 文件夹名字 （创建文件夹） cd 文件夹名字 （进入文件夹） hexo init （初始化） cnpm install （安装依赖） 在github中新建一个仓库，注意！仓库的名字需要在后面加上’.github.io’，不要勾选readme.md，创建 在编辑器中打开上述创建的文件夹，找到最外层的配置文件_config.yml,进入文件内，搜索deploy进行如下更改，repo是我们刚才创建的github的仓库地址 deploy:type: gitrepo: https://github.com/yangxinjian/yangxinjian.github.iobranch: master 完成连接，我们可以通过push，将代码提交到github，也可以通过hexo git push origin master 也会出现Not a git repository (or any of the parent directories): .git这样的错误。这个错误代表在本地与github仓库未进行连接，解决办法如下： 在该目录下输入：git init git add . (提交代码) git commit -m ‘备注’ git remote add origin ‘你的仓库地址’ git push origin master (完成提交) npm install hexo-deployer-git –save hexo g hexo d 在这步骤可能会出现Repository not found.这个错误，这个错误出现，你就要检查一下你的仓库名字和你在配置相中写入到名字是否一致 4.开启运行 本地运行 hexo s -g 线上查看地址 https://你的仓库名字.github.io/ 第二步：配置主题以及基本文字1.配置主题 git clone https://github.com/iissnan/hexo-theme-next themes/next （克隆主题） 在最外层的配置文件中_config.yml 将theme更改为next theme: next 在themes文件夹下的next文件夹下找到主题配置文件_config scheme 分别有四个主题选项，可以随意选择，#代表注释，去掉注释代码生效，一次只可以选择一个主题 social可以增添一些其他社会信息(例如github) social:GitHub: https://github.com/yangxinjian || github avatar可以增添自己的头像(例如github) avatar: http://oqk0uz684.bkt.clouddn.com/WeChat%20Image_20180516113012.jpg pace_theme下的四个为主题动画，将其中一个设置为true，即可以开启当前动画 安装wordcount显示文章字数，在主题的config中搜索wordcount，全部设置为true cnpm install hexo-wordcount –save 安装站内搜索插件,在主题的config中搜索local-search，enable为true cnpm install hexo-generator-searchdb –save 2.基本文字基本文字在最外层的_config文件中配置，例如：标题，描述，作者等信息 title: 杨欣舰的博客 subtitle: description: 小前端的小笔记 keywords: author: Sunny Yang]]></content>
  </entry>
</search>
