<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue 中使用 sass]]></title>
    <url>%2F2018%2F08%2F25%2Fsass%2F</url>
    <content type="text"><![CDATA[Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能 安装(mac下)以及使用 安装 12sudo cnpm install node-sass --save-devsudo cnpm install sass-loader --save-dev 使用 12&lt;style lang=&quot;scss&quot; scoped&gt; //scoped代表只在本页应用的样式&lt;/style&gt; 功能1. 嵌套css允许将一套css样式套进另一套样式中，内层的样式为外层样式的子选择器（1）普通嵌套 scss样式 123456789body &#123; background: red; div &#123; height: 30px; a&#123; display: block; &#125; &#125;&#125; 编译后的css样式 123456789body &#123; background: red;&#125;body div &#123; height: 30px;&#125;body div a&#123; display: block;&#125; （2）父选择器scss 用 &amp; 符号代表嵌套规则外层的父选择器 scss样式 123456a &#123; background: red; &amp;:hover &#123; text-decoration: underline; &#125;&#125; 编译后的css样式 123456a &#123; background: red;&#125;a:hover &#123; text-decoration: underline;&#125; （3）属性嵌套sass允许同一个属性嵌套在命名空间中 scss样式 123456a &#123; font &#123; size: 28px; weight: bold; &#125;&#125; 编译后的css样式 1234a &#123; font-size: 28px; font-weight: bold;&#125; （4）@import嵌套样式 scss样式 123456.text &#123; color: red;&#125;p &#123; @import &apos;text&apos;&#125; 编译后的css样式 123p .text&#123; color: red;&#125; 2. 变量 $变量支持块级作用域，嵌套内定义的变量成为局部变量，只能在当前嵌套内使用，在顶层定义的变量成为全局变量，可以在所用地方使用 !global 可以将局部变量转换为全局变量，用于结尾 scss样式 1234567div &#123; $width: 100px !global; width: $width;&#125;.container &#123; width: $width;&#125; 编译后的css样式 123456div &#123; width: 100px;&#125;.container &#123; width: 100px;&#125; !default 默认变量，不会重新赋值已经赋值的变量，但是没有赋值的变量会赋予值 scss样式 123456789$content: &apos;a little pain&apos;$content: &apos;much pain&apos; !default$value: &apos;lover&apos;p:before &#123; content: $content&#125;a:before&#123; content: $value&#125; 编译后css样式 123456p:before &#123; content: a little pain&#125;a:before&#123; content: &apos;lover&apos;&#125; 3. 字符串 使用#{}时，有引号字符串将被编译为无引号字符串，这样便于在，，mixin中引用选择器名 scss样式 123456@mixin firefox-message($selector) &#123; body.content #&#123;$selector&#125;:before &#123; content: &apos;hi&apos; &#125;&#125;@include firefox-message(&apos;.header&apos;) 编译后的css样式 123body.content .header:before&#123; content: &apos;hi&apos;&#125; 4. 运算 scss样式 123p &#123; font-size: 20px + 10px/2&#125; 编译后的css样式 123p &#123; font-size: 25px;&#125; 5. 插值语句通过#{} 插值语句可以在选择器或属性名中使用变量 scss样式 12345$name: pig$p: paddingp .$name &#123; $p-left: 20px;&#125; 编译后的css样式 123p .pig&#123; padding-left: 20px;&#125; 6. extend继承@extend 的作用是将重复使用的样式延伸给需要包含这个样式的特殊样式 scss样式 12345678$p: paddingp &#123; $p-left: 20px;&#125;div&#123; @extend p border: 1px solid #aaa;&#125; 编译后的css样式 123456p , div &#123; padding-left: 20px;&#125;div&#123; border: 1px solid #aaa;&#125; 7. 控制指令（1）@if scss样式 12345p &#123; @if 1 + 1 == 2 &#123; border: 1px solid #aaa; &#125;&#125; 编译后的css样式 123p &#123; border: 1px solid #aaa;&#125; （2）@for scss样式 12345@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 编译后的css样式 123456789.item-1 &#123; width: 2em;&#125;.item-2 &#123; width: 4em;&#125;.item-3 &#123; width: 6em;&#125; （3）@each scss样式 12345@each $header, $value in (h1: red, h2: blue) &#123; $header &#123; color: $value &#125;&#125; 编译后的css样式 123456h1 &#123; color: red;&#125;h2 &#123; width: blue;&#125; 8. 混合指令混合指令用于定义可重复使用的样式，避免了使用无语意的 class （1）定义混合样式@mixin scss样式 1234567@mixin font-value &#123; font &#123; size: 12px; weight: bold; &#125; color: #fff;&#125; （2）引用混合样式@include scss样式 1234p &#123; @include font-value background: red;&#125; 编译后的css样式 123456p &#123; font-size: 12px; font-weight: bold; color: #fff; background: red;&#125; （3）混合样式带参数 普通参数 sass 1234567891011@mixin args ($color) &#123; font &#123; size: 12px; weight: bold; &#125; color: $color&#125;p &#123; @include args(#fff) background: red;&#125; 编译后的css样式 123456p &#123; font-size: 12px; font-weight: bold; color: #fff; background: red;&#125; 默认参数 sass 12345678910111213@mixin args ($color, $value: 12px) &#123; font &#123; size: $value; weight: bold; &#125; color: $color&#125;p &#123; @include args(#fff, 13px)&#125;a &#123; @include args(red)&#125; 编译后的css样式 12345678910p &#123; font-size: 13px; font-weight: bold; color: #fff;&#125;a &#123; font-size: 12px; font-weight: bold; color: red;&#125; 参数变量 sass 123456@mixin args ($shadow...) &#123; box-shadow: $shadow...&#125;p &#123; @include args(2px 3px 2px #000)&#125; 编译后的css样式 123p &#123; box-shadow: 2px 3px 2px #000;&#125; （4）在混合指令中导入内容@content scss样式 12345678910@mixin name &#123; * html &#123; @content &#125;&#125;@include name &#123; body &#123; background: red; &#125;&#125; 编译后的css样式 123* html body &#123; background: red;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[从零开始自学微信小程序之路]]></title>
    <url>%2F2018%2F08%2F16%2Fwechat%2F</url>
    <content type="text"><![CDATA[1. 使用/安装 配置：在微信公众平台申请小程序账号，下载微信开发者工具，本地创建项目文件夹，并输入appid和项目名称，进入小程序项目WeUI-wxss安装使用：WeUI-wxss是一套同微信原生视觉体验一致的基础样式库,设计规范参考https://github.com/weui/weui-design 123https://github.com/Tencent/weui-wxss下载到本地（git clone https://github.com/Tencent/weui-wxss.git）将weui-wxss/dist/style/weui.wxss放到小程序项目的根目录下在项目中引用：在全局app.wxss中加入weui.wxss的引用- @import &quot;weui.wxss&quot;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[jquery知识点]]></title>
    <url>%2F2018%2F08%2F11%2Fjquery%2F</url>
    <content type="text"><![CDATA[1.属性拷贝 浅拷贝(只复制一份原始对象的引用) 1var newObj = $.extend(&#123;&#125;, oldObject) 深拷贝(对原始对象属性所引用的对象进行递归拷贝) 1var newObj = $.extend(true, &#123;&#125;, oldObject)]]></content>
  </entry>
  <entry>
    <title><![CDATA[ajax小记]]></title>
    <url>%2F2018%2F08%2F11%2Fajax%2F</url>
    <content type="text"><![CDATA[1.ajax实现的步骤123456创建XMLHttpRequest对象创建一个新的HTTP请求，并指定该请求的类型和验证信息设置相应请求状态变化的回调函数发送http请求获取异步调用返回的数据使用javascript和dom进行局部刷新 2.ajax实现的代码123456789var xtr = new XMLHttpRequest()xtr.open(&apos;POST&apos;, url , true)xtr.setRequertHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;)xtr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; (xhr.readyState == 200 || xhr.status == 304)) &#123; fn.call(this, xhr.responseText) &#125;&#125;xtr.send(data)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vuex实现存储用户登录后的用户信息，方便在各个页面中使用]]></title>
    <url>%2F2018%2F07%2F05%2Fvuex%2F</url>
    <content type="text"><![CDATA[1. 安装vuexnpm install vuex --save-dev 2. 建立全局store1.在src文件夹下，新建文件夹（一般我们取名store），并在该文件夹下创建存储数据的js文件。2.在main.js文件下，我们需要将存储的数据文件设置为全局形式，方便引用1234567import store from &apos;./你新建的文件夹文字/你文件夹下的文件名字&apos;new Vue(&#123; el: &apos;#app&apos;, router, store, //这里不要忘记咯 render: h =&gt; h(App)&#125;) 3. 编写js文件1. 在这里，我们要先定义我们的state，用来装所需要存储的数据，初始值是空。12345const state = &#123; user: &#123; &#125;&#125; 2. 接下来我们定义mutation，编写我们要改变的事件，去接受值，参数为两个，一个是state，一个是payLoad（就是我们要存储的所有数据）12345const mutations = &#123; setUserInfo(state, payload) &#123; state.user = payload //现在我们把存储的值都放在state的user对象下 &#125;&#125; 3. 将我们的state和mutation暴漏出去，用于全局引用1234export default new Vuex.Store(&#123; state, mutations&#125;) 4. 登录存储在我们获取登录接口并且服务器返回成功后，进行数据存储 1this.$store.commit(&apos;setUserInfo&apos;, &#123;data:rep.data.data&#125;) 5.调用存储数据1this.$store.state.user//输出结果就是我们存储进去的信息]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue小记知识点]]></title>
    <url>%2F2018%2F06%2F21%2Fvue%2F</url>
    <content type="text"><![CDATA[1. this.$router.go(0) 重新刷新加载页面2. 使用element-ui的日期组件时，如果只是绑定v-model给日期组件，v-model接收的时间为正常时间-1天 解决办法，设置value-format！！！！，文档上写的是value属性，当时小坑了一下 1:value-format=&quot;yyyy-MM&quot; 3. axios下关于put/get/delete/post请求的三种传参方式（1）get/put/delete/post关于path传参方式12345this.$axios.get(&quot;/hospital/ruleDicts/&quot; + 参数) .then(() =&gt; &#123; &#125;) .catch((err) =&gt; &#123; &#125;) （2）get/put/delete/post关于body传参方式12345678that.$axios.put(&quot;/hospital/updateRule/&quot;, &#123; 字段1: 参数值， 字段2: 参数值 &#125;) .then(() =&gt; &#123; &#125;) .catch((err) =&gt; &#123; &#125;) （3）get/put/delete/post关于query传参方式12345that.$axios.put(&quot;/hospital/updatePackageName/&quot;?参数字段=&quot;+参数值) .then((res)=&gt;&#123; &#125;,(err)=&gt;&#123; &#125;).catch((error)=&gt;&#123; &#125;) 4. bus.js实现兄弟之间组件通信（官方文档中只提供了父与子通信） 在文件夹中新建一个文件，随意取名，例如bus.js放在了assets文件夹（文件夹自定义）下，在bus.js文件夹下写入： import Vue from &apos;vue&apos; export default new Vue() 在两个要通信的兄弟组件之间引入bus.js import bus from &apos;你bus.js文件存放的位置&apos; 想要传递信息的兄弟1 &lt;button @click=&quot;toBus&quot;&gt;&lt;/button&gt; methods: { toBus () { bus.$emit(&apos;on&apos;, &apos;这个是兄弟1传给兄弟2的值&apos;) } } 接受传递信息的兄弟2 mounted () { bus.$on(&apos;on&apos;, (msg) =&gt; { console.log(msg) // msg就是从兄弟1接到的数据 }) }]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 知识点]]></title>
    <url>%2F2018%2F06%2F21%2Fjs%2F</url>
    <content type="text"><![CDATA[概念知识点1. JavaScript 实现由 (核心：ECMAScript；文档对象模型：DOM；浏览器对象模型：BOM) 构成。2. 浏览器窗口功能以及navigator对象/location对象/screen对象，对cookie/XMLHttpRequest/ActiveXObject的支持均属于BOMnavigator对象包含有关浏览器的信息，例如：版本appVersion, 名称appName, 操作系统平台platform等 location对象包含有关当前URL的信息，常用：window.location.href获取当前地址或者改变新的地址/window.location.reload()重新加载当前页面 screen对象包含有关客户端显示屏幕的信息，例如：window.screen.height返回屏幕的总高度 3.NaN与任何值都不相等，并且涉及到NaN操作时，均为NaN4.++/– –,++前置时，先运算再赋值 1234var num1 = 10var num2 = 20var num3 = --num1 + num2 =&gt; num3 = 29var num4 = num1 + num2 =&gt; num4 = 29 –,++后置时，先赋值再运算 1234var num1 = 10var num2 = 20var num3 = num1-- + num2 =&gt; num3 = 30var num4 = num1 + num2 =&gt; num4 = 29 5.函数中return后面的语句不会被执行1234function test () &#123; return; alert(1)//alert提示框永远不会弹出&#125; 6.深浅克隆(原生js，也可参考jquery文档下的克隆) 浅克隆（简单的复制对象，如果对象其中一个属性是引用型变量，就会出现负值增生的情况，因为引用型变量保存的是内存地址，所以其实后来操作的都是同一块内存，导致了数组内容都一样。） 1234567891011121314151617var objTemplate = &#123; name: &apos;pig&apos;, username: &apos;杨欣舰&apos;, tag: [&apos;淑女&apos;]&#125;//obj 为初始值对象function simpleCopy (obj) &#123; var newobj = &#123;&#125; for (var i in obj) &#123; newobj[i] = obj[i] &#125; return newobj&#125;var userboy = simpleCopy(objTemplate)userboy.name = &apos;小龙龙&apos;userboy.username = &apos;龙宝&apos;userboy.tag.push(&apos;亲爱的&apos;) 深度克隆（深克隆就是在克隆的时候判断一下属性的类型是不是引用型变量，如果是的话就用递归方法让它一层一层进去复制自己。） 123456789101112function deepCopy (obj, newobj) &#123; var newobj = newobj || &#123;&#125; for (var i in obj) &#123; if (typeof obj[i] == &apos;Object&apos;) &#123; newobj[i] = (obj[i].construtor === Array) ? [] : &#123;&#125; deepCopy(obj[i], newobj[i]) &#125; else &#123; newobj[i] = obj[i] &#125; &#125; return newobj&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[css小技巧]]></title>
    <url>%2F2018%2F06%2F14%2Fcss%2F</url>
    <content type="text"><![CDATA[1.元素居中(1) 块状元素居中1234.box &#123; width: 100px; margin: o auto;&#125; (2) 浮动元素居中（不提倡）123456789.box &#123; position: absolute; width: 100px; height: 100px; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px;&#125; (3) flex元素居中（超级实用）12345.box &#123; display: flex; justify-content: center; 一行下的水平居中 align-items: center; 多行的竖直居中&#125; 2.伪类####（1）相同class的index检索 123456:last-child 检索最后一个值:first-child 检索第一个值:nth-child(index) 从头开始检索index个值，index初始值为1:nth-last-child(index) 从尾开始检索index个值，index为1默认倒数第一个（这个比较坑）:nth-child(odd) 检索基数:nth-child(even) 检索偶数 找出倒数第几个的样式，这个伪类还是很帅气的，之前写一个项目，li下面又放了一个标签，怎么调节li最后一个都不变，但是因为li有同级最后，那就不是最后一个元素，后来使用nth-last-child(2)就弄好了 ####（2）::before写出小三角 .box{ position: relative; left:100px; width: 140px; min-height: 70px; background: #f6dbd8; -moz-border-radius: 12px; -webkit-border-radius: 12px; border-radius: 12px; padding: 5px 10px; word-wrap: break-word; } .box:before{ 三角形区域 position: absolute; content: &quot;&quot;; width: 0; height: 0; right: 100%; top: 38px; border-top: 13px solid transparent; border-right: 26px solid #f6dbd8; border-bottom: 13px solid transparent; } 3.去除input标签默认点击边框outline: none; 4.编写一个小三角1234567.demo&#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent tansparent red transparent;&#125; 5.box-sizing box-sizing: content-box; //默认的标准盒模型元素效果（w3c）box-sizing: border-box; //默认的怪异盒模型元素效果（ie）box-sizing: inherit; //继承父元素box-sizing的属性值 6.移动端适配css插件 – cssrem（vscode下安装步骤）1. 在vscode的扩展商店，搜索cssrem 2. 点击安装，安装后，点击重新加载 3. 加载完成后，打开设置，在右边配置输入中，可以设置转换长度，&quot;cssrem-rootFontSize&quot;]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用正则表达式]]></title>
    <url>%2F2018%2F05%2F21%2Fzhengze%2F</url>
    <content type="text"><![CDATA[简单语法糖123456&apos;^&apos;放在开头，验证是否以...开头&apos;$&apos;放在结尾，验证是否以...结尾&apos;[]&apos;验证出现过的字符&apos;()&apos;验证出现过的字符串&apos;-&apos;连接符，常用[a-z],[A-Z],[0-9],[\u4e00-\u9fa5]&apos;^&apos;放到中间，代表不包含 使用const ZHENG = /^a/ const str = &apos;aaaaooo&apos; console.log(ZHENG.test(str)) 控制台输出：true 经典验证1.验证数字 ^[0-9]*$ 2.验证n位的数字(字符串内容为纯数字的也支持) ^\d{n}$ 3.验证至少n位的数字(字符串内容为纯数字的也支持) ^\d{n,}$ 4.验证m-n位的数字（字符串内容为纯数字的也支持） ^\d{m,n}$ 5.0和非0开头的数字 ^(0|[1-9][0-9]*)$ 6.汉字 ^[\u4e00-\u9fa5]{0,}$ 7.长度为m-n的所有字符 ^.{m,n}$ 8.以字母数字下划线开头的字符串 ^[A-Za-z0-9_]$ 9.Email地址 ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 10.空格 /\s*/g]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS常用功能小算法]]></title>
    <url>%2F2018%2F05%2F21%2Fmethod%2F</url>
    <content type="text"><![CDATA[字符串1.为字符串每一个字符中插入其他字符(举例子：每一个字符之间插入空格)1234function test (str) &#123; return str.split(&apos;&apos;).join(&apos; &apos;)&#125;console.log(test(&apos;hello pig&apos;)) 控制台输出：h e l l o p i g 2.数组去重 es6方法 12345function uni (arr) &#123; return Array.from(new Set(arr))&#125;var _arr = [&apos;1&apos;, 22, &apos;aa&apos;, &apos;1&apos;, 33, 33]console.log(uni(_arr)) 再简单一点 12const a = arr =&gt; [...new Set(arr)]console.log(a([&apos;1&apos;, 22, &apos;aa&apos;, &apos;1&apos;, 33, 33])) 控制台输出：[‘1’, 22, ‘aa’, 33] es5方法 12345678var arr = [1, 3, 4, 4, 2, 3, 1]var arr1 = []for (var i = 0; i &lt; arr.length; i++) &#123; if (arr1.indexof(arr[i]) &lt; 0) &#123; arr1.push(arr[i]) &#125;&#125;console.log(arr1) 控制台输出[1, 3, 4, 2] 3.数组并集1234u (a, b) &#123; return Array.from(new Set([..a, ..b]))&#125;console.log(u ([1,2,3,2,1], [3,2,1,5])) 控制台输出 [1,2,3,5] 4.数组交集1234n (a, b) &#123; return Array.from(new Set([...a].filter(x =&gt; new Set(b).has(x))))&#125;console.log(u ([1,2,3,2,1], [3,2,1,5])) 控制台输出 [1,2,3] 5.数组差级123cha (a, b) &#123; return [...a.filter(x =&gt; !new Set (b).has(x)), ...b.filter(x =&gt; !new Set (a).has(x))]&#125; 控制台输出 [5] 6.对应转换（举例数字月份转换成文字月份）123var mapTree = new Map([[&apos;01&apos;,&apos;一月&apos;],[&apos;02&apos;,&apos;二月&apos;],[&apos;03&apos;,&apos;三月&apos;],[&apos;04&apos;,&apos;四月&apos;],[&apos;05&apos;,&apos;五月&apos;],[&apos;06&apos;,&apos;六月&apos;],[&apos;07&apos;,&apos;七月&apos;],[&apos;08&apos;,&apos;八月&apos;],[&apos;09&apos;,&apos;九月&apos;],[&apos;10&apos;,&apos;十月&apos;],[&apos;11&apos;,&apos;十一月&apos;],[&apos;12&apos;,&apos;十二月&apos;]])console.log(mapTree.get(&apos;01&apos;)) 控制台输出 一月 7.检测一个变量是否为某一个类型(三种方式)123typeof(obj) === &apos;string&apos;typeof obj === &apos;string&apos;obj.constructor === &apos;string&apos; 8.去掉字符串的空格（1）正则+replaceconst str = &apos; a a a f &apos; str = str.replace(/\s*/g, &apos;&apos;) console.log(str) 控制台输出：aaaf （2）trim()const str = &apos; a a a f &apos; console.log(str.trim()) 控制台输出：a a a f(trim无法去掉中间的空格) 9.将某个字符串改写成驼峰形式（独立单词首字母大写）1234567let str = &apos;get-element-by-id&apos;let target = &apos;&apos;let arr = str.split(&apos;-&apos;)arr.forEach((item) =&gt; &#123; target += item.substr(0, 1).toUpperCase() + item.substr(1)&#125;)console.log(target) 控制台输出：GetElementById 10.随机抽取n个10-100的数12345678getNum (n) &#123; var arr = [] for (let i = 0; i &lt; n ; i ++) &#123; arr.push(parseInt(Math.random() * 90 + 10)) &#125; return n&#125;getNum(10) 控制台输出10个10-100之间的数字 找出数组中的最大差值123456789var arr = [1,3,13,234,234,11,334]var minNum = arr[0]var maxCha = 0arr.forEach((item) =&gt; &#123; minNum = Math.min(minNum, item) let cha = item - minNum maxCha = Math.max(maxCha, cha)&#125;)console.log(maxCha) 控制台输出： 333 计算一个整数的阶乘12345678add (n) &#123; if (n == 1) &#123; return 1 &#125; else &#123; return n * add(n-1) &#125;&#125;console.log(add(5)) 控制台输出 120]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS常见的‘坑’]]></title>
    <url>%2F2018%2F05%2F17%2Fjs_keng%2F</url>
    <content type="text"><![CDATA[ES6小坑1.ES6为参数提供了默认值，在定义函数的同时初始化了这个参数，以便在参数没有被传递进去使用123function test (arg = 100) &#123; console.log(num)&#125; test(0) =&gt; 0test() =&gt; 100test(200) =&gt; 200 相对于ES5，arg = arg || 100这样设置参数默认值的时候，传入0时，就会输出false 2.ES6重构代码第一题： var jsonParse = require(&apos;body-parser&apos;).jsonParse import { jsonParse } from ‘body-parser’ 第二题： var body = request.body var username = body.username var password = body.password const {body, body: { username , password} } = request 3.‘…’ 组装对象或者数组 12const color = [&apos;red&apos;, &apos;yellow&apos;, &apos;blue&apos;]const colorful = [...color, &apos;green&apos;, &apos;pink&apos;] colorful =&gt; [‘red’, ‘yellow’, ‘blue’, ‘green’, ‘pink’] 12const people = &#123; name: &apos;pig&apos;, sex: &apos;female&apos;&#125;const newpeople = &#123; ...people, age: &apos;18&apos;&#125; newpeople =&gt; { name: ‘pig’, sex: ‘female’, age: ‘18’} 获取数组或者对象中除了前几项的其他项或者除了某项中的其他项 12const number = [1, 2, 3, 4, 5]const [first, ...rest] = number rest =&gt; 2, 3, 4, 5 12const user = &#123; name: &apos;pig&apos;, age: &apos;18&apos;, sex: &apos;female&apos;&#125;const &#123; name, ...rest &#125; = user rest =&gt; { age: ‘18’, sex: ‘female’ } 组合新对象，当两个对象合并有重复的时候，右面的属性名覆盖左面属性名 123const first = &#123; a: 1, b: 2, c: 3&#125;const second = &#123; c: 6, d: 4, e: 5&#125;const tatol = &#123; ...fisrt, ...second &#125; total =&gt; { a: 1, b: 2, c: 6, d: 4, e: 5} 4.promise12345678910111213setTimeout ( () =&gt; &#123; console.log(1) &#125;,0) new Promise ( (resolve) =&gt; &#123; console.log(2) for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve() &#125; console.log(3) &#125;).then(() =&gt; &#123; console.log(4) &#125;) console.log(5) 控制台输出：2，3，5，4，1 这道题主要为js的运行机制，首先setTimeout，设置了一个定时，定时结束后才会将这个函数放到任务队列里面，所以最后输出 promise的函数均是立即执行，所以直接输出2，3 then放到当前的tick最后，所以先输出5后在输出4，最后的定时的1 1234567891011const promise = new Promise((resolve, reject) =&gt; &#123; resolve(&apos;success1&apos;) reject(&apos;error&apos;) resolve(&apos;success2&apos;) &#125;) promise.then((res) =&gt; &#123; console.log(&apos;then: &apos;, res) &#125;) .catch((err) =&gt; &#123; console.log(&apos;catch: &apos;, err) &#125;) 控制台输出：then：success1 promise只会识别一种状态，当识别到了resolve状态时，后面的状态就忽略了，resolve代表成功，所以走的是then，输出success1 JS小坑1.循环，闭包，加延时123for (var i = 0; i &lt; 5; i ++) &#123; console.log(i)&#125; 输出：0，1，2，3，4 正常输出值 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout( () =&gt; &#123; console.log(i) &#125;, 1000 * i)&#125; 输出：5，5，5，5，5 因为for循环是一次性走完的，但是添加了异步的操作，当for循环结束后，i的作用域还存在，而且在他的内部还可以访问，所以就等于5了 1234567for (var i = 0; i &lt; 5; i++) &#123; ((i) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, i * 1000) &#125;)(i)&#125; 输出：0，1，2，3，4 添加了闭包操作，没执行一次i循环，就会一秒后输出i值 1234567for (var i = 0; i &lt; 5; i++) &#123; (() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, i * 1000) &#125;)(i)&#125; 输出：5，5，5，5，5 添加了闭包操作，但是（）内没有添加闭包值，没有对i保持引用，所以还是输出5 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(((i) =&gt; &#123; console.log(i) &#125;)(i), i * 1000)&#125; 立即输出，没有延时：0，1，2，3，4 setTimeout这里传递了一个立即执行函数，所以后面的延时时间不进行考虑，所以立即输出0，1，2，3，4 2.循环，闭包（1）循环 123456789101112131415test6 () &#123; var results = this.count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2];&#125;,count() &#123; var arr = []; for (var i = 1; i &lt;= 3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125; f1 =&gt; function () { return i * i } f2 =&gt; function () { return i * i } f3 =&gt; function () { return i * i } f1() =&gt; 16 push的时候只是定义了函数，在执行时，i已经变成了4 f2() =&gt; 16 f3() =&gt; 16 （2）将（1）中的循环改成闭包 123456789101112131415161718test6 () &#123; var results = this.count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2];&#125;,count() &#123; var arr = []; for (var i = 1; i &lt;= 3; i++) &#123; arr.push((function(n)&#123; return function () &#123; return n * n; &#125; &#125;)(i)); // console.log(i) &#125; return arr;&#125; f1 =&gt; function () { return n * n } f2 =&gt; function () { return n * n } f3 =&gt; function () { return n * n } f1() =&gt; 1 f2() =&gt; 4 f3() =&gt; 9 (3) 将（1）中的var改成let时，var的作用域是在count下，let转换成块级作用域，所以在for循环{}下，所以当我们在var的基础上执行函数count，作用域变成了结束循环的i值，而let的作用域保持在每一次循环的i 123456789101112131415161718test6 () &#123; var results = this.count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2]; console.log(f1()) console.log(f2()) console.log(f3())&#125;,count() &#123; var arr = []; for (let i = 1; i &lt;= 3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125; 3.延时setTimeout（1）队列执行 123456var flag = truesetTimeout ( () =&gt; &#123; flag = false&#125;, 1000)while(flag) &#123;&#125;alert(&apos;1&apos;) 永远不会弹出1，因为在while中是死循环，虽然setTimeout只延时了一秒执行，但是主队列中的while会永远的执行下去，所在settimeout的队列永远不会被执行，代码阻塞在while循环这面（2）内存泄漏 123456789setTimeout (function test1 () &#123; var a = 1 console.log(`a:$(a)`)&#125;,0)setTimeout ((function test2 () &#123; var b = 1 console.log(`b:$&#123;b&#125;`)&#125;).toString(), 0) 两个定时延时，第一个传入的参数是函数，函数回调之后，test1（）函数被摧毁，内存被释放 第二传入的参数是字符串，会被解析成eval（string），他是一个全局变量函数，不存在被摧毁，始终占据内存，造成了内存泄漏。 4.this(1)在return中返回 1234567function getName() &#123; this.name = 1 return &#123;&#125;&#125;var a = new getName()console.log(a)console.log(a.name) 控制台输出 {} , undifined return返回的是一个空对象，所以new也是为空 123456function getName () &#123; this.name = 1 return 2&#125;var d = new getName()console.log(d.name) 控制台输出 1 return返回的是一个非空对象，所以new实例getName()方法 （2）this被谁调用就指向谁 12345678910111213var x = 0 var foo = &#123; x: 1, bar: &#123; x: 2, baz: function () &#123; console.log(this.x) &#125; &#125;&#125;var a = foo.bar.bazfoo.bar.baz()a() 控制台输出 2 0 baz()是被bar调用，所以this指向bar中的x2 a()是被windows调用，所以指向windows下的x0 1234567891011var x = 0function foo () &#123; var x = 1 function baz()&#123; console.log(this.x) &#125; return baz&#125;var a = foo()foo()()a() 控制台输出 0 0 foo()()是函数调用，是全局的指向，所以是windows下的x0 a()是被windows调用，所以指向windows下的x0 (3) new实例对象中的this 1234567var name = &apos;yang&apos;function person() &#123; this.name = &apos;zhu&apos;&#125;var a = new person()console.log(a.name)console.log(name) 控制台输出 zhu yang a重新实例了person对象，所以this指向当前对象下的值 （4）apply 12345678910var x = 0function test() &#123; console.log(this.x)&#125;var o = &#123;&#125;o.x = 1o.m = testo.m()o.m.apply()o.m.apply(o) 控制台输出 1 0 1 o里面新添入x属性和m属性，m属性赋值一个函数，m属于o，当o.m()的时候，m是被o调用的，所以m里面的this指向是o里面的x，也就是1 o.m.apply(),apply的作用是给函数设置一个this指向,当传入的参数没有，或者为null或者undifined的时候，指向全局，所以相当于在windows下调用，所以this指向x0 apply()中参数存在，指向o中的x为1 （5）闭包中的this 12345678910111213var x = 0var foo = &#123; x: 1, bar: function ()&#123; console.log(this.x) var that = this return function () &#123; console.log(this.x) console.log(that.x) &#125; &#125;&#125;foo.bar()() =》 let bar = foo() bar() 控制台输出 1 0 1 第一个（）输出的值是foo调用，所以是1 闭包返回的this调用的不是对象而是下一个函数，所以指向的是全局，所以是0 闭包返回的that是接受了上一步的this，所以是1 5.自执行12345678var z = 10;function foo() &#123; console.log(z)&#125;(function (funArg)&#123; var z = 20; funArg ()&#125;)(foo) 控制台输出： 10 因为下面的自执行是传入的foo这个函数，然后里面调用了这个函数，他能拿到的作用域只有外部的，里面的z不管他的事儿 6.变量123456789var a = 100function function_name(argument) &#123; var b = 2 * a var a = 200 var c = a / 2 alert(b) alert(c)&#125;function_name() alert弹出，NaN , 100 因为在函数内部，会在内部先找a，找不到a就会去外面寻找，当执行的时候，会查询当前作用域的变量，但不会立即赋值，简单来说：函数执行时，在{}内部产生一个作用域，查找该{}内的所有变量，函数名，常量这些，如果找不到，才会去外面找对应的，变量的提升就是，变量在申明之前也可以使用，但是值是undefined]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建属于你的专属博客]]></title>
    <url>%2F2018%2F05%2F15%2Ftest%2F</url>
    <content type="text"><![CDATA[第一步：安装以及运行1.安装git以及node环境（官网下载即可）2.在node的环境下安装hexo cnpm install -g hexo-cli cnpm install -g hexo hexo -v 检验是否安装成功 3.本地创建放置博客文章文件并与github相连接 mkdir 文件夹名字 （创建文件夹） cd 文件夹名字 （进入文件夹） hexo init （初始化） cnpm install （安装依赖） 在github中新建一个仓库，注意！仓库的名字需要在后面加上’.github.io’，不要勾选readme.md，创建 在编辑器中打开上述创建的文件夹，找到最外层的配置文件_config.yml,进入文件内，搜索deploy进行如下更改，repo是我们刚才创建的github的仓库地址 deploy:type: gitrepo: https://github.com/yangxinjian/yangxinjian.github.iobranch: master 完成连接，我们可以通过push，将代码提交到github，也可以通过hexo git push origin master 也会出现Not a git repository (or any of the parent directories): .git这样的错误。这个错误代表在本地与github仓库未进行连接，解决办法如下： 在该目录下输入：git init git add . (提交代码) git commit -m ‘备注’ git remote add origin ‘你的仓库地址’ git push origin master (完成提交) npm install hexo-deployer-git –save hexo g hexo d 在这步骤可能会出现Repository not found.这个错误，这个错误出现，你就要检查一下你的仓库名字和你在配置相中写入到名字是否一致 4.开启运行 本地运行 hexo s -g 线上查看地址 https://你的仓库名字.github.io/ 第二步：配置主题以及基本文字1.配置主题 git clone https://github.com/iissnan/hexo-theme-next themes/next （克隆主题） 在最外层的配置文件中_config.yml 将theme更改为next theme: next 在themes文件夹下的next文件夹下找到主题配置文件_config scheme 分别有四个主题选项，可以随意选择，#代表注释，去掉注释代码生效，一次只可以选择一个主题 social可以增添一些其他社会信息(例如github) social:GitHub: https://github.com/yangxinjian || github avatar可以增添自己的头像(例如github) avatar: http://oqk0uz684.bkt.clouddn.com/WeChat%20Image_20180516113012.jpg pace_theme下的四个为主题动画，将其中一个设置为true，即可以开启当前动画 安装wordcount显示文章字数，在主题的config中搜索wordcount，全部设置为true cnpm install hexo-wordcount –save 安装站内搜索插件,在主题的config中搜索local-search，enable为true cnpm install hexo-generator-searchdb –save 2.基本文字基本文字在最外层的_config文件中配置，例如：标题，描述，作者等信息 title: 杨欣舰的博客 subtitle: description: 小前端的小笔记 keywords: author: Sunny Yang]]></content>
  </entry>
</search>
